// Generated by ReScript, PLEASE EDIT WITH CARE

import Kaplay from "kaplay";
import * as Vitest from "vitest";
import * as Stdlib_Array from "@rescript/runtime/lib/es6/Stdlib_Array.mjs";
import * as Pkmn$Skirmish from "../src/Pkmn.res.mjs";
import * as Team$Skirmish from "../src/Team.res.mjs";
import * as Ember$Skirmish from "../src/Moves/Ember.res.mjs";
import * as Attack$Skirmish from "../src/Moves/Attack.res.mjs";
import * as AIFacts$Skirmish from "../src/EnemyAI/AIFacts.res.mjs";
import * as EnemyAI$Skirmish from "../src/EnemyAI.res.mjs";
import * as Pokemon$Skirmish from "../src/Pokemon.res.mjs";
import * as ZeroMove$Skirmish from "../src/Moves/ZeroMove.res.mjs";
import * as GenericMove$Skirmish from "./GenericMove.res.mjs";
import * as Thundershock$Skirmish from "../src/Moves/Thundershock.res.mjs";

function withKaplayContext(playingField, enemyMove1Opt, testFn) {
  let enemyMove1 = enemyMove1Opt !== undefined ? enemyMove1Opt : ZeroMove$Skirmish.move;
  let k = Kaplay({
    width: 160,
    height: 160,
    global: false,
    background: "#000000",
    scale: 1,
    crisp: true
  });
  Pkmn$Skirmish.load(k, 4);
  Pkmn$Skirmish.load(k, 25);
  Thundershock$Skirmish.load();
  Ember$Skirmish.load(k);
  return new Promise((resolve, reject) => {
    if (playingField.length === 0) {
      reject(new Error("Playing field is empty"));
    }
    let xDimension = playingField[0].length;
    if (!playingField.every(row => row.length === xDimension)) {
      reject(new Error("All rows must have the same length"));
    }
    k.onError(error => {
      k.quit();
      reject(error);
    });
    k.onLoad(() => {
      let xDimension = playingField[0].length;
      let yDimension = playingField.length;
      let halfTile = 32 / 2;
      for (let y = 0; y < yDimension; ++y) {
        for (let x = 0; x < xDimension; ++x) {
          let tile = playingField[y].charAt(x);
          switch (tile) {
            case "." :
              break;
            case "A" :
              let x$1 = x * 32 + halfTile;
              let y$1 = y * 32 + halfTile;
              GenericMove$Skirmish.make(k, x$1, y$1, 32, true);
              break;
            case "E" :
              let x$2 = x * 32 + halfTile;
              let y$2 = y * 32 + halfTile;
              let enemy = Pkmn$Skirmish.make(k, 4, 5, enemyMove1, undefined, undefined, undefined, false);
              Pkmn$Skirmish.assignOpponent(enemy);
              enemy.pos = k.vec2(x$2, y$2);
              break;
            case "P" :
              let x$3 = x * 32 + halfTile;
              let y$3 = y * 32 + halfTile;
              let player = Pkmn$Skirmish.make(k, 25, 12, undefined, undefined, undefined, undefined, true);
              Pkmn$Skirmish.assignPlayer(player);
              player.pos = k.vec2(x$3, y$3);
              break;
            default:
              reject(new Error(`Invalid tile: ` + tile + `, expected P, E, A, .`));
          }
        }
      }
      let enemies = k.query({
        include: [
          Pokemon$Skirmish.tag,
          Team$Skirmish.opponent
        ]
      });
      if (enemies.length !== 1) {
        reject(new Error(`Expected exactly 1 enemy, found ` + enemies.length.toString()));
      }
      let players = k.query({
        include: [
          Pokemon$Skirmish.tag,
          Team$Skirmish.player
        ]
      });
      if (players.length !== 1) {
        reject(new Error(`Expected exactly 1 player, found ` + players.length.toString()));
      }
      let rs = EnemyAI$Skirmish.makeRuleSystem(k, enemies[0], players[0]);
      testFn(k, rs).then(resolve).catch(reject).finally(() => {
        k.quit();
      });
    });
  });
}

Vitest.test("player attack right in center of enemy", () => withKaplayContext([
  "..E..",
  ".....",
  "..A..",
  ".....",
  "..P.."
], undefined, async (k, rs) => {
  let enemyMoveSpy = Vitest.vi.spyOn(rs.state.enemy, "move");
  EnemyAI$Skirmish.update(k, rs, undefined);
  Vitest.expect(rs.state.horizontalMovement).toBe(false);
  Vitest.expect(enemyMoveSpy).toHaveBeenCalled();
}));

Vitest.test("player attack on the right of enemy", () => withKaplayContext([
  "..E..",
  ".....",
  "....A",
  ".....",
  "..P.."
], undefined, async (k, rs) => {
  EnemyAI$Skirmish.update(k, rs, undefined);
  Vitest.expect(rs.state.horizontalMovement).toBeUndefined();
  Vitest.expect(rs.facts.has(AIFacts$Skirmish.attackOnTheRightOfEnemy)).toBeTruthy();
}));

Vitest.test("player attack on the left of enemy", () => withKaplayContext([
  "..E..",
  ".....",
  "A....",
  ".....",
  "..P.."
], undefined, async (k, rs) => {
  EnemyAI$Skirmish.update(k, rs, undefined);
  Vitest.expect(rs.state.horizontalMovement).toBeUndefined();
  Vitest.expect(rs.facts.has(AIFacts$Skirmish.attackOnTheLeftOfEnemy)).toBeTruthy();
}));

Vitest.test("enemy should move to the right to be in front of player", () => withKaplayContext([
  ".E...",
  ".....",
  "....P"
], undefined, async (k, rs) => {
  let enemyMoveSpy = Vitest.vi.spyOn(rs.state.enemy, "move");
  EnemyAI$Skirmish.update(k, rs, undefined);
  Vitest.expect(rs.state.horizontalMovement).toBe(false);
  Vitest.expect(enemyMoveSpy).toHaveBeenCalled();
}));

Vitest.test("enemy should move to the left to be in front of player", () => withKaplayContext([
  "....E",
  ".....",
  "P...."
], undefined, async (k, rs) => {
  let enemyMoveSpy = Vitest.vi.spyOn(rs.state.enemy, "move");
  EnemyAI$Skirmish.update(k, rs, undefined);
  Vitest.expect(rs.state.horizontalMovement).toBe(true);
  Vitest.expect(enemyMoveSpy).toHaveBeenCalled();
}));

Vitest.test("enemy should not move when in front of player", () => withKaplayContext([
  ".E.",
  ".P."
], undefined, async (k, rs) => {
  let enemyMoveSpy = Vitest.vi.spyOn(rs.state.enemy, "move");
  EnemyAI$Skirmish.update(k, rs, undefined);
  Vitest.expect(rs.state.horizontalMovement).toBeUndefined();
  Vitest.expect(enemyMoveSpy).not.toHaveBeenCalled();
  Vitest.expect(rs.facts.has(AIFacts$Skirmish.isPlayerLeft)).toBeFalsy();
  Vitest.expect(rs.facts.has(AIFacts$Skirmish.isPlayerRight)).toBeFalsy();
}));

Vitest.test("enemy should attack when not under threat and can attack", () => withKaplayContext([
  "..E..",
  ".....",
  "..P.."
], Ember$Skirmish.move, async (k, rs) => {
  rs.state.enemy.attackStatus = [
    0,
    1,
    2,
    3
  ];
  EnemyAI$Skirmish.update(k, rs, undefined);
  let enemyAttacks = Stdlib_Array.filterMap(k.query({
    include: [
      Attack$Skirmish.tag,
      Team$Skirmish.opponent
    ],
    hierarchy: "descendants"
  }), Attack$Skirmish.Unit.fromGameObj);
  Vitest.expect(enemyAttacks.length).toBe(1);
  Vitest.expect(rs.facts.has(EnemyAI$Skirmish.AttackFacts.shouldAttack)).toBeTruthy();
}));

Vitest.test("enemy should not attack when under threat", () => withKaplayContext([
  "..E..",
  "..A..",
  "..P.."
], undefined, async (k, rs) => {
  rs.state.enemy.attackStatus = [
    0,
    1,
    2,
    3
  ];
  EnemyAI$Skirmish.update(k, rs, undefined);
  let enemyAttacks = Stdlib_Array.filterMap(k.query({
    include: [
      Attack$Skirmish.tag,
      Team$Skirmish.opponent
    ],
    hierarchy: "descendants"
  }), Attack$Skirmish.Unit.fromGameObj);
  Vitest.expect(enemyAttacks.length).toBe(0);
}));

Vitest.test("enemy should not attack when already attacking", () => withKaplayContext([
  "..E..",
  ".....",
  "..P.."
], undefined, async (k, rs) => {
  rs.state.enemy.attackStatus = "CannotAttack";
  EnemyAI$Skirmish.update(k, rs, undefined);
  let enemyAttacks = Stdlib_Array.filterMap(k.query({
    include: [
      Attack$Skirmish.tag,
      Team$Skirmish.opponent
    ],
    hierarchy: "descendants"
  }), Attack$Skirmish.Unit.fromGameObj);
  Vitest.expect(enemyAttacks.length).toBe(0);
}));

export {
  withKaplayContext,
}
/*  Not a pure module */
