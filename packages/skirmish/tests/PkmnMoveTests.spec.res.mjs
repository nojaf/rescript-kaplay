// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Vitest from "vitest";
import * as Pervasives from "@rescript/runtime/lib/es6/Pervasives.mjs";
import * as Pkmn$Skirmish from "../src/Pkmn.res.mjs";
import * as PkmnMove$Skirmish from "../src/PkmnMove.res.mjs";
import * as ZeroMove$Skirmish from "../src/Moves/ZeroMove.res.mjs";

function makeTestMove(idOpt, coolDownDurationOpt, maxPPOpt) {
  let id = idOpt !== undefined ? idOpt : 1;
  let coolDownDuration = coolDownDurationOpt !== undefined ? coolDownDurationOpt : 1.0;
  let maxPP = maxPPOpt !== undefined ? maxPPOpt : 10;
  return {
    id: id,
    name: "Test Move",
    maxPP: maxPP,
    baseDamage: 10,
    coolDownDuration: coolDownDuration,
    cast: (_k, _pkmn) => {},
    addRulesForAI: (_k, _rs, _slot, _facts) => {}
  };
}

function makeTestSlot(move, currentPP, lastUsedAtOpt) {
  let lastUsedAt = lastUsedAtOpt !== undefined ? lastUsedAtOpt : Pervasives.neg_infinity;
  return {
    move: move,
    currentPP: currentPP,
    lastUsedAt: lastUsedAt
  };
}

Vitest.test("canCast returns true when PP > 0, not ZeroMove, and cooldown elapsed", () => {
  let move = makeTestMove(undefined, 1.0, undefined);
  let slot = makeTestSlot(move, 5, 0.0);
  Vitest.expect(PkmnMove$Skirmish.canCast(slot, 2.0)).toBe(true);
  return Promise.resolve();
});

Vitest.test("canCast returns false when PP is 0", () => {
  let move = makeTestMove(undefined, 1.0, undefined);
  let slot = makeTestSlot(move, 0, 0.0);
  Vitest.expect(PkmnMove$Skirmish.canCast(slot, 2.0)).toBe(false);
  return Promise.resolve();
});

Vitest.test("canCast returns false for ZeroMove (id = -1)", () => {
  let slot = makeTestSlot(ZeroMove$Skirmish.move, 10, undefined);
  Vitest.expect(PkmnMove$Skirmish.canCast(slot, 100.0)).toBe(false);
  return Promise.resolve();
});

Vitest.test("canCast returns false when cooldown has not elapsed", () => {
  let move = makeTestMove(undefined, 2.0, undefined);
  let slot = makeTestSlot(move, 5, 1.0);
  Vitest.expect(PkmnMove$Skirmish.canCast(slot, 2.0)).toBe(false);
  return Promise.resolve();
});

Vitest.test("canCast returns true exactly when cooldown duration has elapsed", () => {
  let move = makeTestMove(undefined, 2.0, undefined);
  let slot = makeTestSlot(move, 5, 1.0);
  Vitest.expect(PkmnMove$Skirmish.canCast(slot, 3.0)).toBe(true);
  return Promise.resolve();
});

Vitest.test("canCast returns true when lastUsedAt is neg_infinity (never used)", () => {
  let move = makeTestMove(undefined, 10.0, undefined);
  let slot = makeTestSlot(move, 5, undefined);
  Vitest.expect(PkmnMove$Skirmish.canCast(slot, 0.0)).toBe(true);
  return Promise.resolve();
});

Vitest.test("getAvailableMoveIndices returns all indices when all moves available", () => {
  let move = makeTestMove(undefined, undefined, undefined);
  let slot1 = makeTestSlot(move, 10, undefined);
  let slot2 = makeTestSlot(move, 10, undefined);
  let slot3 = makeTestSlot(move, 10, undefined);
  let slot4 = makeTestSlot(move, 10, undefined);
  let result = Pkmn$Skirmish.getAvailableMoveIndices(slot1, slot2, slot3, slot4, 0.0);
  Vitest.expect(result).toHaveLength(4);
  Vitest.expect(result.includes(0)).toBeTruthy();
  Vitest.expect(result.includes(1)).toBeTruthy();
  Vitest.expect(result.includes(2)).toBeTruthy();
  Vitest.expect(result.includes(3)).toBeTruthy();
  return Promise.resolve();
});

Vitest.test("getAvailableMoveIndices returns only available move indices", () => {
  let move = makeTestMove(undefined, 1.0, undefined);
  let slot1 = makeTestSlot(move, 5, undefined);
  let slot2 = makeTestSlot(move, 0, undefined);
  let slot3 = makeTestSlot(move, 5, undefined);
  let slot4 = makeTestSlot(move, 5, 0.5);
  let result = Pkmn$Skirmish.getAvailableMoveIndices(slot1, slot2, slot3, slot4, 1.0);
  Vitest.expect(result).toHaveLength(2);
  Vitest.expect(result.includes(0)).toBeTruthy();
  Vitest.expect(result.includes(2)).toBeTruthy();
  return Promise.resolve();
});

Vitest.test("getAvailableMoveIndices returns empty array when no moves available", () => {
  let move = makeTestMove(undefined, 2.0, undefined);
  let slot1 = makeTestSlot(move, 0, undefined);
  let slot2 = makeTestSlot(move, 0, undefined);
  let slot3 = makeTestSlot(move, 0, undefined);
  let slot4 = makeTestSlot(move, 0, undefined);
  let result = Pkmn$Skirmish.getAvailableMoveIndices(slot1, slot2, slot3, slot4, 0.0);
  Vitest.expect(result).toHaveLength(0);
  return Promise.resolve();
});

Vitest.test("getAvailableMoveIndices excludes ZeroMove slots", () => {
  let move = makeTestMove(undefined, undefined, undefined);
  let slot1 = makeTestSlot(move, 10, undefined);
  let slot2 = makeTestSlot(ZeroMove$Skirmish.move, 0, undefined);
  let slot3 = makeTestSlot(ZeroMove$Skirmish.move, 0, undefined);
  let slot4 = makeTestSlot(ZeroMove$Skirmish.move, 0, undefined);
  let result = Pkmn$Skirmish.getAvailableMoveIndices(slot1, slot2, slot3, slot4, 0.0);
  Vitest.expect(result).toHaveLength(1);
  Vitest.expect(result.includes(0)).toBeTruthy();
  return Promise.resolve();
});

Vitest.test("getAvailableMoveIndices with mixed move states", () => {
  let move1 = makeTestMove(1, 1.0, undefined);
  let move2 = makeTestMove(2, 2.0, undefined);
  let slot1 = makeTestSlot(move1, 3, 0.0);
  let slot2 = makeTestSlot(move2, 5, 0.5);
  let slot3 = makeTestSlot(ZeroMove$Skirmish.move, 0, undefined);
  let slot4 = makeTestSlot(move1, 1, undefined);
  let result = Pkmn$Skirmish.getAvailableMoveIndices(slot1, slot2, slot3, slot4, 1.0);
  Vitest.expect(result).toHaveLength(2);
  Vitest.expect(result.includes(0)).toBeTruthy();
  Vitest.expect(result.includes(3)).toBeTruthy();
  return Promise.resolve();
});

export {
  makeTestMove,
  makeTestSlot,
}
/*  Not a pure module */
