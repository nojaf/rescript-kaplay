// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Attack$Skirmish from "../Moves/Attack.res.mjs";
import * as AIFacts$Skirmish from "./AIFacts.res.mjs";

function overlapX(param, param$1) {
  return Math.max(param[0], param$1[0]) <= Math.min(param[1], param$1[1]);
}

function addRules(k, rs) {
  rs.addRuleExecutingAction(rs => rs.state.playerAttacks.length !== 0, rs => {
    let leftGrade = {
      contents: 0
    };
    let rightGrade = {
      contents: 0
    };
    let centerGrade = {
      contents: 0
    };
    let enemyWorldPos = rs.state.enemy.worldPos();
    let enemyStartX = enemyWorldPos.x - rs.state.enemy.halfSize;
    let enemyEndX = enemyWorldPos.x + rs.state.enemy.halfSize;
    rs.state.playerAttacks.forEach(attack => {
      let attackWorldRect = attack.getWorldRect();
      let closestCorner = Attack$Skirmish.Unit.getClosestCorner(attack, k, enemyWorldPos);
      if (overlapX([
          enemyStartX,
          enemyEndX
        ], [
          attackWorldRect.pos.x,
          attackWorldRect.pos.x + attackWorldRect.width
        ])) {
        let squaredDistance = enemyWorldPos.sdist(attackWorldRect.center());
        let currentGrade = squaredDistance === 0 ? 1 : rs.state.enemy.squaredPersonalSpace / squaredDistance;
        if (centerGrade.contents < currentGrade) {
          centerGrade.contents = currentGrade;
          return;
        } else {
          return;
        }
      }
      if (closestCorner.x < enemyStartX) {
        let squaredDistance$1 = closestCorner.sdist(enemyWorldPos);
        let currentGrade$1 = squaredDistance$1 === 0 ? 1 : rs.state.enemy.squaredPersonalSpace / squaredDistance$1;
        if (leftGrade.contents < currentGrade$1) {
          leftGrade.contents = currentGrade$1;
          return;
        } else {
          return;
        }
      }
      if (closestCorner.x <= enemyEndX) {
        return;
      }
      let squaredDistance$2 = closestCorner.sdist(enemyWorldPos);
      let currentGrade$2 = squaredDistance$2 === 0 ? 1 : rs.state.enemy.squaredPersonalSpace / squaredDistance$2;
      if (rightGrade.contents < currentGrade$2) {
        rightGrade.contents = currentGrade$2;
        return;
      }
    });
    if (leftGrade.contents > 0) {
      rs.assertFact(AIFacts$Skirmish.attackOnTheLeftOfEnemy, leftGrade.contents);
    }
    if (rightGrade.contents > 0) {
      rs.assertFact(AIFacts$Skirmish.attackOnTheRightOfEnemy, rightGrade.contents);
    }
    if (centerGrade.contents > 0) {
      rs.assertFact(AIFacts$Skirmish.attackInCenterOfEnemy, centerGrade.contents);
      return;
    }
  }, 0.0);
  rs.addRuleExecutingAction(_rs => true, rs => {
    let enemyWorldPos = rs.state.enemy.worldPos();
    let enemyStartX = enemyWorldPos.x - rs.state.enemy.halfSize;
    let enemyEndX = enemyWorldPos.x + rs.state.enemy.halfSize;
    let leftSpace = enemyStartX / k.width();
    let rightSpace = (k.width() - enemyEndX) / k.width();
    if (leftSpace > 0) {
      rs.assertFact(AIFacts$Skirmish.hasSpaceOnTheLeft, leftSpace);
    }
    if (rightSpace > 0) {
      rs.assertFact(AIFacts$Skirmish.hasSpaceOnTheRight, rightSpace);
      return;
    }
  }, 0.0);
  rs.addRuleExecutingAction(_rs => true, rs => {
    let enemyWorldPos = rs.state.enemy.worldPos();
    let playerWorldPos = rs.state.player.worldPos();
    let horizontalDistance = playerWorldPos.x - enemyWorldPos.x;
    if (Math.abs(horizontalDistance) < 1.0) {
      return;
    } else {
      if (horizontalDistance < 0.0) {
        rs.assertFact(AIFacts$Skirmish.isPlayerLeft, 1.0);
      } else {
        rs.assertFact(AIFacts$Skirmish.isPlayerRight, 1.0);
      }
      return;
    }
  }, 0.0);
}

let salience = 0.0;

export {
  salience,
  overlapX,
  addRules,
}
/* Attack-Skirmish Not a pure module */
