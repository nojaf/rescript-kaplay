// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib_Array from "@rescript/runtime/lib/es6/Stdlib_Array.js";
import * as Team$Skirmish from "./Team.res.mjs";
import * as Attack$Skirmish from "./Moves/Attack.res.mjs";
import * as Pokemon$Skirmish from "./Pokemon.res.mjs";
import * as RuleSystem$Kaplay from "@nojaf/rescript-kaplay/src/RuleSystem.res.mjs";
import * as DebugRuleSystem$Skirmish from "./DebugRuleSystem.res.mjs";

let attackInCenterOfEnemy = "attackInCenterOfEnemy";

let attackOnTheLeftOfEnemy = "attackOnTheLeftOfEnemy";

let attackOnTheRightOfEnemy = "attackOnTheRightOfEnemy";

let Facts = {
  playerCentered: "playerCentered",
  playerBelow: "playerBelow",
  attackInCenterOfEnemy: attackInCenterOfEnemy,
  attackOnTheLeftOfEnemy: attackOnTheLeftOfEnemy,
  attackOnTheRightOfEnemy: attackOnTheRightOfEnemy
};

let Salience = {
  baseFacts: 0.0,
  derivedFacts: 10.0,
  decisions: 20.0
};

function isPlayerCentered(rs) {
  let distance = Math.round(Math.abs(rs.state.enemy.pos.x - rs.state.player.pos.x));
  return distance === 0;
}

function isPlayerBelow(rs) {
  return rs.state.enemy.pos.y < rs.state.player.pos.y;
}

function negate(predicate) {
  return rs => !predicate(rs);
}

function overlapX(param, param$1) {
  return Math.max(param[0], param$1[0]) <= Math.min(param[1], param$1[1]);
}

function makeRuleSystem(k, enemy, player) {
  let rs = RuleSystem$Kaplay.make(k);
  rs.state = {
    enemy: enemy,
    player: player,
    playerAttacks: [],
    lastAttackAt: 0
  };
  rs.addRuleExecutingAction(rs => rs.state.playerAttacks.length !== 0, rs => {
    let leftGrade = {
      contents: 0
    };
    let rightGrade = {
      contents: 0
    };
    let centerGrade = {
      contents: 0
    };
    let enemyWorldPos = rs.state.enemy.worldPos();
    let enemyStartX = enemyWorldPos.x - rs.state.enemy.halfSize;
    let enemyEndX = enemyWorldPos.x + rs.state.enemy.halfSize;
    rs.state.playerAttacks.forEach(attack => {
      let attackWorldRect = attack.getWorldRect();
      let closestCorner = Attack$Skirmish.Unit.getClosestCorner(attack, k, enemyWorldPos);
      if (overlapX([
          enemyStartX,
          enemyEndX
        ], [
          attackWorldRect.pos.x,
          attackWorldRect.pos.x + attackWorldRect.width
        ])) {
        let squaredDistance = enemyWorldPos.sdist(attackWorldRect.center());
        let currentGrade = squaredDistance === 0 ? 1 : rs.state.enemy.squaredPersonalSpace / squaredDistance;
        if (centerGrade.contents < currentGrade) {
          centerGrade.contents = currentGrade;
          return;
        } else {
          return;
        }
      }
      if (closestCorner.x < enemyStartX) {
        let squaredDistance$1 = closestCorner.sdist(enemyWorldPos);
        let currentGrade$1 = squaredDistance$1 === 0 ? 1 : rs.state.enemy.squaredPersonalSpace / squaredDistance$1;
        if (leftGrade.contents < currentGrade$1) {
          leftGrade.contents = currentGrade$1;
          return;
        } else {
          return;
        }
      }
      if (closestCorner.x <= enemyEndX) {
        return;
      }
      let squaredDistance$2 = closestCorner.sdist(enemyWorldPos);
      let currentGrade$2 = squaredDistance$2 === 0 ? 1 : rs.state.enemy.squaredPersonalSpace / squaredDistance$2;
      if (rightGrade.contents < currentGrade$2) {
        rightGrade.contents = currentGrade$2;
        return;
      }
    });
    if (leftGrade.contents > 0) {
      rs.assertFact(attackOnTheLeftOfEnemy, leftGrade.contents);
    }
    if (rightGrade.contents > 0) {
      rs.assertFact(attackOnTheRightOfEnemy, rightGrade.contents);
    }
    if (centerGrade.contents > 0) {
      rs.assertFact(attackInCenterOfEnemy, centerGrade.contents);
      return;
    }
  }, 0.0);
  return rs;
}

function getPlayerAttacks(k) {
  return Stdlib_Array.filterMap(k.query({
    include: [
      Attack$Skirmish.tag,
      Team$Skirmish.player
    ],
    hierarchy: "descendants"
  }), Attack$Skirmish.Unit.fromGameObj);
}

let forOf = (function (items, callback, shouldBreak) {
  for (let i = 0; i < items.length; i++) {
    if (shouldBreak()) {
      break;
    }
    callback(items[i])
  }
});

function update(k, rs, param) {
  rs.reset();
  rs.state.playerAttacks = getPlayerAttacks(k);
  rs.execute();
}

function make(k, pokemonId, level, player) {
  let enemy = Pokemon$Skirmish.make(k, pokemonId, level, false);
  let rs = makeRuleSystem(k, enemy, player);
  enemy.onUpdate(extra => update(k, rs, extra));
  DebugRuleSystem$Skirmish.make(k, rs);
  return enemy;
}

export {
  Facts,
  Salience,
  isPlayerCentered,
  isPlayerBelow,
  negate,
  overlapX,
  makeRuleSystem,
  getPlayerAttacks,
  forOf,
  update,
  make,
}
/* Attack-Skirmish Not a pure module */
