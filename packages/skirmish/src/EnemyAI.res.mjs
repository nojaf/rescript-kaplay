// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Team$Skirmish from "./Team.res.mjs";
import * as Attack$Skirmish from "./Moves/Attack.res.mjs";
import * as Pokemon$Skirmish from "./Pokemon.res.mjs";
import * as RuleSystem$Kaplay from "@nojaf/rescript-kaplay/src/RuleSystem.res.mjs";

let playerCentered = "playerCentered";

let playerBelow = "playerBelow";

let Facts = {
  playerCentered: playerCentered,
  playerBelow: playerBelow
};

function isPlayerCentered(rs) {
  let distance = Math.round(Math.abs(rs.state.self.pos.x - rs.state.opponent.pos.x));
  return distance === 0;
}

function isPlayerBelow(rs) {
  return rs.state.self.pos.y < rs.state.opponent.pos.y;
}

function negate(predicate) {
  return rs => !predicate(rs);
}

function make(k, pokemonId, level, player) {
  let enemy = Pokemon$Skirmish.make(k, pokemonId, level, false);
  let rs = RuleSystem$Kaplay.make(k);
  rs.state = {
    self: enemy,
    opponent: player,
    lastAttackAt: 0
  };
  rs.addRuleAssertingFact(isPlayerCentered, playerCentered, 1);
  rs.addRuleRetractingFact(rs => !isPlayerCentered(rs), playerCentered, 1);
  rs.addRuleAssertingFact(isPlayerBelow, playerBelow, 1);
  rs.addRuleRetractingFact(rs => !isPlayerBelow(rs), playerBelow, 1);
  enemy.onUpdate(() => {
    rs.reset();
    let playerAttacks = k.query({
      include: [
        Attack$Skirmish.tag,
        Team$Skirmish.player
      ],
      hierarchy: "descendants"
    });
    if (playerAttacks.length !== 0) {
      playerAttacks.forEach(attack => {
        console.log("Player attack", attack.getWorldRect());
      });
    }
    rs.execute();
    let g = rs.gradeForFact(playerCentered);
    if (g >= 1.0) {
      return;
    }
    let deltaX = Math.round(player.pos.x - enemy.pos.x);
    if (deltaX === 0) {
      return;
    }
    let x = deltaX > 0 ? 120 : -120;
    enemy.move(k.vec2(x, 0));
  });
  return enemy;
}

export {
  Facts,
  isPlayerCentered,
  isPlayerBelow,
  negate,
  make,
}
/* Pokemon-Skirmish Not a pure module */
