// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib_Array from "@rescript/runtime/lib/es6/Stdlib_Array.js";
import * as Team$Skirmish from "./Team.res.mjs";
import * as Attack$Skirmish from "./Moves/Attack.res.mjs";
import * as Pokemon$Skirmish from "./Pokemon.res.mjs";
import * as RuleSystem$Kaplay from "@nojaf/rescript-kaplay/src/RuleSystem.res.mjs";
import * as DebugRuleSystem$Skirmish from "./DebugRuleSystem.res.mjs";

let attackInCenterOfEnemy = "attackInCenterOfEnemy";

let attackOnTheLeftOfEnemy = "attackOnTheLeftOfEnemy";

let attackOnTheRightOfEnemy = "attackOnTheRightOfEnemy";

let hasSpaceOnTheLeft = "hasSpaceOnTheLeft";

let hasSpaceOnTheRight = "hasSpaceOnTheRight";

function overlapX(param, param$1) {
  return Math.max(param[0], param$1[0]) <= Math.min(param[1], param$1[1]);
}

function makeRuleSystem(k, enemy, player) {
  let rs = RuleSystem$Kaplay.make(k);
  rs.state = {
    enemy: enemy,
    player: player,
    playerAttacks: [],
    dodgeDirection: undefined,
    lastAttackAt: 0
  };
  rs.addRuleExecutingAction(rs => rs.state.playerAttacks.length !== 0, rs => {
    let leftGrade = {
      contents: 0
    };
    let rightGrade = {
      contents: 0
    };
    let centerGrade = {
      contents: 0
    };
    let enemyWorldPos = rs.state.enemy.worldPos();
    let enemyStartX = enemyWorldPos.x - rs.state.enemy.halfSize;
    let enemyEndX = enemyWorldPos.x + rs.state.enemy.halfSize;
    rs.state.playerAttacks.forEach(attack => {
      let attackWorldRect = attack.getWorldRect();
      let closestCorner = Attack$Skirmish.Unit.getClosestCorner(attack, k, enemyWorldPos);
      if (overlapX([
          enemyStartX,
          enemyEndX
        ], [
          attackWorldRect.pos.x,
          attackWorldRect.pos.x + attackWorldRect.width
        ])) {
        let squaredDistance = enemyWorldPos.sdist(attackWorldRect.center());
        let currentGrade = squaredDistance === 0 ? 1 : rs.state.enemy.squaredPersonalSpace / squaredDistance;
        if (centerGrade.contents < currentGrade) {
          centerGrade.contents = currentGrade;
          return;
        } else {
          return;
        }
      }
      if (closestCorner.x < enemyStartX) {
        let squaredDistance$1 = closestCorner.sdist(enemyWorldPos);
        let currentGrade$1 = squaredDistance$1 === 0 ? 1 : rs.state.enemy.squaredPersonalSpace / squaredDistance$1;
        if (leftGrade.contents < currentGrade$1) {
          leftGrade.contents = currentGrade$1;
          return;
        } else {
          return;
        }
      }
      if (closestCorner.x <= enemyEndX) {
        return;
      }
      let squaredDistance$2 = closestCorner.sdist(enemyWorldPos);
      let currentGrade$2 = squaredDistance$2 === 0 ? 1 : rs.state.enemy.squaredPersonalSpace / squaredDistance$2;
      if (rightGrade.contents < currentGrade$2) {
        rightGrade.contents = currentGrade$2;
        return;
      }
    });
    if (leftGrade.contents > 0) {
      rs.assertFact(attackOnTheLeftOfEnemy, leftGrade.contents);
    }
    if (rightGrade.contents > 0) {
      rs.assertFact(attackOnTheRightOfEnemy, rightGrade.contents);
    }
    if (centerGrade.contents > 0) {
      rs.assertFact(attackInCenterOfEnemy, centerGrade.contents);
      return;
    }
  }, 0.0);
  rs.addRuleExecutingAction(_rs => true, _rs => {
    let enemyWorldPos = rs.state.enemy.worldPos();
    let enemyStartX = enemyWorldPos.x - rs.state.enemy.halfSize;
    let enemyEndX = enemyWorldPos.x + rs.state.enemy.halfSize;
    let leftSpace = enemyStartX / k.width();
    let rightSpace = (k.width() - enemyEndX) / k.width();
    if (leftSpace > 0) {
      rs.assertFact(hasSpaceOnTheLeft, leftSpace);
    }
    if (rightSpace > 0) {
      rs.assertFact(hasSpaceOnTheRight, rightSpace);
      return;
    }
  }, 0.0);
  rs.addRuleExecutingAction(rs => {
    let c = rs.gradeForFact(attackInCenterOfEnemy);
    return c > 0.0;
  }, rs => {
    let centerAttack = rs.gradeForFact(attackInCenterOfEnemy);
    let leftAttack = rs.gradeForFact(attackOnTheLeftOfEnemy);
    let rightAttack = rs.gradeForFact(attackOnTheRightOfEnemy);
    let leftSpace = rs.gradeForFact(hasSpaceOnTheLeft);
    let rightSpace = rs.gradeForFact(hasSpaceOnTheRight);
    let leftThreat = leftAttack + centerAttack;
    let rightThreat = rightAttack + centerAttack;
    let match;
    if (leftThreat > rightThreat) {
      match = [
        false,
        true
      ];
    } else if (rightThreat > leftThreat) {
      match = [
        true,
        true
      ];
    } else {
      let currentDirection = rs.state.dodgeDirection;
      match = currentDirection !== undefined ? [
          currentDirection,
          false
        ] : [
          leftSpace > rightSpace,
          true
        ];
    }
    let preferredDodgeDirection = match[0];
    let finalDirection;
    if (match[1]) {
      let hasSpaceInPreferred;
      hasSpaceInPreferred = preferredDodgeDirection === true ? leftSpace > 0.0 : rightSpace > 0.0;
      finalDirection = hasSpaceInPreferred ? preferredDodgeDirection : (
          preferredDodgeDirection === true ? rightSpace <= 0.0 : leftSpace > 0.0
        );
    } else {
      let dir = rs.state.dodgeDirection;
      finalDirection = dir !== undefined ? dir : preferredDodgeDirection;
    }
    let currentDirection$1 = rs.state.dodgeDirection;
    if (currentDirection$1 !== undefined && currentDirection$1 === finalDirection) {
      return;
    } else {
      rs.state.dodgeDirection = finalDirection;
      return;
    }
  }, 20.0);
  rs.addRuleExecutingAction(rs => {
    let c = rs.gradeForFact(attackInCenterOfEnemy);
    return c === 0.0;
  }, rs => {
    rs.state.dodgeDirection = undefined;
  }, 20.0);
  return rs;
}

function getPlayerAttacks(k) {
  return Stdlib_Array.filterMap(k.query({
    include: [
      Attack$Skirmish.tag,
      Team$Skirmish.player
    ],
    hierarchy: "descendants"
  }), Attack$Skirmish.Unit.fromGameObj);
}

function update(k, rs, param) {
  rs.reset();
  rs.state.playerAttacks = getPlayerAttacks(k);
  rs.execute();
  let match = rs.state.dodgeDirection;
  if (match !== undefined) {
    if (match === true) {
      return Pokemon$Skirmish.moveLeft(k, rs.state.enemy);
    } else {
      return Pokemon$Skirmish.moveRight(k, rs.state.enemy);
    }
  }
}

function make(k, pokemonId, level, player) {
  let enemy = Pokemon$Skirmish.make(k, pokemonId, level, false);
  let rs = makeRuleSystem(k, enemy, player);
  enemy.onUpdate(extra => update(k, rs, extra));
  DebugRuleSystem$Skirmish.make(k, rs);
  return enemy;
}

export {
  make,
  makeRuleSystem,
  update,
}
/* Attack-Skirmish Not a pure module */
