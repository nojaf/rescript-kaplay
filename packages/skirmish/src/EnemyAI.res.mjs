// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Team$Skirmish from "./Team.res.mjs";
import * as Ember$Skirmish from "./Moves/Ember.res.mjs";
import * as Attack$Skirmish from "./Moves/Attack.res.mjs";
import * as Pokemon$Skirmish from "./Pokemon.res.mjs";
import * as RuleSystem$Kaplay from "@nojaf/rescript-kaplay/src/RuleSystem.res.mjs";

let playerCentered = "playerCentered";

let playerBelow = "playerBelow";

let attackIncoming = "attackIncoming";

let Facts = {
  playerCentered: playerCentered,
  playerBelow: playerBelow,
  attackIncoming: attackIncoming
};

function isPlayerCentered(rs) {
  let distance = Math.round(Math.abs(rs.state.enemy.pos.x - rs.state.player.pos.x));
  return distance === 0;
}

function isPlayerBelow(rs) {
  return rs.state.enemy.pos.y < rs.state.player.pos.y;
}

function isAttackIncoming(rs) {
  let selfX = rs.state.enemy.pos.x;
  let halfWidth = rs.state.enemy.width / 2;
  let safetyMargin = Math.random() * 10;
  let selfStartX = selfX - halfWidth - safetyMargin;
  let selfEndX = selfX + halfWidth + safetyMargin;
  return rs.state.playerAttacks.some(attack => {
    let attackStartX = attack.pos.x;
    let attackEndX = attack.pos.x + attack.width;
    if (selfStartX <= attackEndX) {
      return attackStartX <= selfEndX;
    } else {
      return false;
    }
  });
}

function negate(predicate) {
  return rs => !predicate(rs);
}

function makeRuleSystem(k, enemy, player) {
  let rs = RuleSystem$Kaplay.make(k);
  rs.state = {
    enemy: enemy,
    player: player,
    playerAttacks: [],
    lastAttackAt: 0
  };
  rs.addRuleAssertingFact(isPlayerCentered, playerCentered, 1);
  rs.addRuleRetractingFact(rs => !isPlayerCentered(rs), playerCentered, 1);
  rs.addRuleAssertingFact(isPlayerBelow, playerBelow, 1);
  rs.addRuleRetractingFact(rs => !isPlayerBelow(rs), playerBelow, 1);
  rs.addRuleAssertingFact(isAttackIncoming, attackIncoming, 1);
  rs.addRuleRetractingFact(rs => !isAttackIncoming(rs), attackIncoming, 1);
  return rs;
}

function getPlayerAttacks(k) {
  return k.query({
    include: [
      Attack$Skirmish.tag,
      Team$Skirmish.player
    ],
    hierarchy: "descendants"
  }).map(attack => attack.getWorldRect());
}

let forOf = (function (items, callback, shouldBreak) {
  for (let i = 0; i < items.length; i++) {
    if (shouldBreak()) {
      break;
    }
    callback(items[i])
  }
});

function verifyAttacks(rs) {
  let attackOnTheLeft = {
    contents: false
  };
  let attackOnTheRight = {
    contents: false
  };
  let enemyX = rs.state.enemy.pos.x;
  forOf(rs.state.playerAttacks, attack => {
    let attackX = attack.pos.x;
    if (attackX < enemyX) {
      attackOnTheLeft.contents = true;
      return;
    } else if (attackX > enemyX) {
      attackOnTheRight.contents = true;
      return;
    } else {
      return;
    }
  }, () => {
    if (attackOnTheLeft.contents) {
      return attackOnTheRight.contents;
    } else {
      return false;
    }
  });
  return [
    attackOnTheLeft.contents,
    attackOnTheRight.contents
  ];
}

function update(k, rs, param) {
  rs.reset();
  rs.state.playerAttacks = getPlayerAttacks(k);
  rs.execute();
  let match = verifyAttacks(rs);
  let attackOnTheRight = match[1];
  let attackOnTheLeft = match[0];
  console.log("grades", rs.facts.entries().toArray());
  let match$1 = rs.gradeForFact(attackIncoming);
  let match$2 = rs.gradeForFact(playerCentered);
  if (match$1 > 0.0) {
    console.log("attackInComingGrade", match$1);
    if (attackOnTheLeft) {
      rs.state.enemy.move(k.vec2(40, 0));
      return;
    }
    if (attackOnTheRight) {
      rs.state.enemy.move(k.vec2(-40, 0));
      return;
    }
    let distanceLeft = rs.state.enemy.pos.x;
    let distanceRight = k.width() - rs.state.enemy.pos.x;
    if (distanceLeft > distanceRight) {
      rs.state.enemy.move(k.vec2(-40, 0));
    } else {
      rs.state.enemy.move(k.vec2(40, 0));
    }
    return;
  }
  if (match$2 >= 1.0) {
    if (match$2 === 1.0 && rs.state.enemy.attackStatus === true) {
      return Ember$Skirmish.cast(rs.state.enemy);
    } else {
      return;
    }
  }
  let deltaX = Math.round(rs.state.player.pos.x - rs.state.enemy.pos.x);
  if (deltaX > 0 && !attackOnTheRight) {
    rs.state.enemy.move(k.vec2(120, 0));
    return;
  } else if (deltaX < 0 && !attackOnTheLeft) {
    rs.state.enemy.move(k.vec2(-120, 0));
    return;
  } else {
    return;
  }
}

function make(k, pokemonId, level, player) {
  let enemy = Pokemon$Skirmish.make(k, pokemonId, level, false);
  let rs = makeRuleSystem(k, enemy, player);
  enemy.onUpdate(extra => update(k, rs, extra));
  return enemy;
}

export {
  Facts,
  isPlayerCentered,
  isPlayerBelow,
  isAttackIncoming,
  negate,
  makeRuleSystem,
  getPlayerAttacks,
  forOf,
  verifyAttacks,
  update,
  make,
}
/* Ember-Skirmish Not a pure module */
