// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Team$Skirmish from "./Team.res.mjs";
import * as Ember$Skirmish from "./Moves/Ember.res.mjs";
import * as Attack$Skirmish from "./Moves/Attack.res.mjs";
import * as Pokemon$Skirmish from "./Pokemon.res.mjs";
import * as RuleSystem$Kaplay from "@nojaf/rescript-kaplay/src/RuleSystem.res.mjs";

let playerCentered = "playerCentered";

let playerBelow = "playerBelow";

let attackIncoming = "attackIncoming";

let Facts = {
  playerCentered: playerCentered,
  playerBelow: playerBelow,
  attackIncoming: attackIncoming
};

function isPlayerCentered(rs) {
  let distance = Math.round(Math.abs(rs.state.self.pos.x - rs.state.opponent.pos.x));
  return distance === 0;
}

function isPlayerBelow(rs) {
  return rs.state.self.pos.y < rs.state.opponent.pos.y;
}

function isAttackIncoming(rs) {
  let selfX = rs.state.self.pos.x;
  let halfWidth = rs.state.self.width / 2;
  let safetyMargin = Math.random() * 10;
  let selfStartX = selfX - halfWidth - safetyMargin;
  let selfEndX = selfX + halfWidth + safetyMargin;
  return rs.state.opponentAttacks.some(attack => {
    let attackStartX = attack.pos.x;
    let attackEndX = attack.pos.x + attack.width;
    if (selfStartX <= attackEndX) {
      return attackStartX <= selfEndX;
    } else {
      return false;
    }
  });
}

function negate(predicate) {
  return rs => !predicate(rs);
}

function make(k, pokemonId, level, player) {
  let enemy = Pokemon$Skirmish.make(k, pokemonId, level, false);
  let rs = RuleSystem$Kaplay.make(k);
  rs.state = {
    self: enemy,
    opponent: player,
    opponentAttacks: [],
    lastAttackAt: 0
  };
  rs.addRuleAssertingFact(isPlayerCentered, playerCentered, 1);
  rs.addRuleRetractingFact(rs => !isPlayerCentered(rs), playerCentered, 1);
  rs.addRuleAssertingFact(isPlayerBelow, playerBelow, 1);
  rs.addRuleRetractingFact(rs => !isPlayerBelow(rs), playerBelow, 1);
  rs.addRuleAssertingFact(isAttackIncoming, attackIncoming, 1);
  rs.addRuleRetractingFact(rs => !isAttackIncoming(rs), attackIncoming, 1);
  enemy.onUpdate(() => {
    rs.reset();
    let playerAttacks = k.query({
      include: [
        Attack$Skirmish.tag,
        Team$Skirmish.player
      ],
      hierarchy: "descendants"
    }).map(attack => attack.getWorldRect());
    rs.state.opponentAttacks = playerAttacks;
    rs.execute();
    let attackOnTheLeft = {
      contents: false
    };
    let attackOnTheRight = {
      contents: false
    };
    playerAttacks.forEach(attack => {
      if (attack.pos.x < enemy.pos.x) {
        attackOnTheLeft.contents = true;
        return;
      } else if (attack.pos.x > enemy.pos.x) {
        attackOnTheRight.contents = true;
        return;
      } else {
        return;
      }
    });
    let attackOnTheLeft$1 = attackOnTheLeft.contents;
    let attackOnTheRight$1 = attackOnTheRight.contents;
    let match = rs.gradeForFact(attackIncoming);
    let match$1 = rs.gradeForFact(playerCentered);
    if (match > 0.0) {
      if (attackOnTheLeft$1) {
        enemy.move(k.vec2(40, 0));
        return;
      } else if (attackOnTheRight$1) {
        enemy.move(k.vec2(-40, 0));
        return;
      } else {
        return;
      }
    }
    if (match$1 >= 1.0) {
      if (match$1 === 1.0 && enemy.attackStatus === true) {
        return Ember$Skirmish.cast(enemy);
      } else {
        return;
      }
    }
    let deltaX = Math.round(player.pos.x - enemy.pos.x);
    if (deltaX > 0 && !attackOnTheRight$1) {
      enemy.move(k.vec2(120, 0));
      return;
    } else if (deltaX < 0 && !attackOnTheLeft$1) {
      enemy.move(k.vec2(-120, 0));
      return;
    } else {
      return;
    }
  });
  return enemy;
}

export {
  Facts,
  isPlayerCentered,
  isPlayerBelow,
  isAttackIncoming,
  negate,
  make,
}
/* Ember-Skirmish Not a pure module */
