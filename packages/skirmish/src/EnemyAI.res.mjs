// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Team$Skirmish from "./Team.res.mjs";
import * as Attack$Skirmish from "./Moves/Attack.res.mjs";
import * as Pokemon$Skirmish from "./Pokemon.res.mjs";
import * as RuleSystem$Kaplay from "@nojaf/rescript-kaplay/src/RuleSystem.res.mjs";
import * as DebugRuleSystem$Skirmish from "./DebugRuleSystem.res.mjs";

let attackOnTheLeftOfEnemy = "attackOnTheLeftOfEnemy";

let Facts = {
  playerCentered: "playerCentered",
  playerBelow: "playerBelow",
  attackInFrontOfEnemy: "attackInFrontOfEnemy",
  attackOnTheLeftOfEnemy: attackOnTheLeftOfEnemy,
  attackOnTheRightOfEnemy: "attackOnTheRightOfEnemy"
};

function isPlayerCentered(rs) {
  let distance = Math.round(Math.abs(rs.state.enemy.pos.x - rs.state.player.pos.x));
  return distance === 0;
}

function isPlayerBelow(rs) {
  return rs.state.enemy.pos.y < rs.state.player.pos.y;
}

function negate(predicate) {
  return rs => !predicate(rs);
}

function makeRuleSystem(k, enemy, player) {
  let rs = RuleSystem$Kaplay.make(k);
  rs.state = {
    enemy: enemy,
    player: player,
    playerAttacks: [],
    lastAttackAt: 0
  };
  rs.addRuleExecutingAction(rs => rs.state.playerAttacks.length !== 0, rs => {
    let grade = {
      contents: 0
    };
    rs.state.playerAttacks.forEach(attack => {
      if (attack.pos.x + attack.width >= rs.state.enemy.pos.x) {
        return;
      }
      let attackCoord = attack.pos.y + attack.height >= rs.state.enemy.pos.y ? k.vec2(attack.pos.x + attack.width, attack.pos.y) : k.vec2(attack.pos.x + attack.width, attack.pos.y + attack.height);
      let squaredDistance = attackCoord.sdist(rs.state.enemy.worldPos());
      let enemyWidth = Math.pow(3 * rs.state.enemy.width, 2);
      let currentGrade = squaredDistance === 0 ? 1 : enemyWidth / squaredDistance;
      if (grade.contents < currentGrade) {
        grade.contents = currentGrade;
        return;
      }
    });
    if (grade.contents > 0) {
      rs.assertFact(attackOnTheLeftOfEnemy, grade.contents);
      return;
    }
  }, 0);
  return rs;
}

function getPlayerAttacks(k) {
  return k.query({
    include: [
      Attack$Skirmish.tag,
      Team$Skirmish.player
    ],
    hierarchy: "descendants"
  }).map(attack => attack.getWorldRect());
}

let forOf = (function (items, callback, shouldBreak) {
  for (let i = 0; i < items.length; i++) {
    if (shouldBreak()) {
      break;
    }
    callback(items[i])
  }
});

function verifyAttacks(rs) {
  let attackOnTheLeft = {
    contents: false
  };
  let attackOnTheRight = {
    contents: false
  };
  let enemyX = rs.state.enemy.pos.x;
  forOf(rs.state.playerAttacks, attack => {
    let attackX = attack.pos.x;
    if (attackX < enemyX) {
      attackOnTheLeft.contents = true;
      return;
    } else if (attackX > enemyX) {
      attackOnTheRight.contents = true;
      return;
    } else {
      return;
    }
  }, () => {
    if (attackOnTheLeft.contents) {
      return attackOnTheRight.contents;
    } else {
      return false;
    }
  });
  return [
    attackOnTheLeft.contents,
    attackOnTheRight.contents
  ];
}

function update(k, rs, param) {
  rs.reset();
  rs.state.playerAttacks = getPlayerAttacks(k);
  rs.execute();
}

function make(k, pokemonId, level, player) {
  let enemy = Pokemon$Skirmish.make(k, pokemonId, level, false);
  let rs = makeRuleSystem(k, enemy, player);
  enemy.onUpdate(extra => update(k, rs, extra));
  DebugRuleSystem$Skirmish.make(k, rs);
  return enemy;
}

export {
  Facts,
  isPlayerCentered,
  isPlayerBelow,
  negate,
  makeRuleSystem,
  getPlayerAttacks,
  forOf,
  verifyAttacks,
  update,
  make,
}
/* Pokemon-Skirmish Not a pure module */
