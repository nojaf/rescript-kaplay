// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.mjs";
import * as Team$Skirmish from "./Team.res.mjs";
import * as Stdlib_JsError from "@rescript/runtime/lib/es6/Stdlib_JsError.mjs";
import * as Pokemon$Skirmish from "./Pokemon.res.mjs";
import * as Belt_MutableQueue from "@rescript/runtime/lib/es6/Belt_MutableQueue.mjs";
import * as GameOver$Skirmish from "./GameOver.res.mjs";
import * as PkmnMove$Skirmish from "./PkmnMove.res.mjs";
import * as ZeroMove$Skirmish from "./Moves/ZeroMove.res.mjs";

function frontSpriteName(id) {
  return "pokemon-" + id.toString() + "-front";
}

function backSpriteName(id) {
  return "pokemon-" + id.toString() + "-back";
}

function frontSpriteUrl(id) {
  return `/sprites/` + id.toString() + `-front.png`;
}

function backSpriteUrl(id) {
  return `/sprites/` + id.toString() + `-back.png`;
}

function load(k, id) {
  k.loadSprite(frontSpriteName(id), frontSpriteUrl(id), {
    singular: true
  });
  k.loadSprite(backSpriteName(id), backSpriteUrl(id), {
    singular: true
  });
}

function getHealthPercentage(pokemon) {
  let currentHp = pokemon.hp;
  let maxHp = pokemon.maxHP;
  return currentHp / maxHp * 100;
}

function moveLeft(k, pokemon) {
  pokemon.move(k.vec2(-100, 0));
}

function moveRight(k, pokemon) {
  pokemon.move(k.vec2(100, 0));
}

function getAvailableMoveIndices(slot1, slot2, slot3, slot4, currentTime) {
  let moves = [];
  if (PkmnMove$Skirmish.canCast(slot1, currentTime)) {
    moves.push(0);
  }
  if (PkmnMove$Skirmish.canCast(slot2, currentTime)) {
    moves.push(1);
  }
  if (PkmnMove$Skirmish.canCast(slot3, currentTime)) {
    moves.push(2);
  }
  if (PkmnMove$Skirmish.canCast(slot4, currentTime)) {
    moves.push(3);
  }
  return moves;
}

function dispatch(pokemon, event) {
  Belt_MutableQueue.add(pokemon.eventQueue, event);
}

function delayedDispatch(k, pokemon, event, delay) {
  k.wait(delay, () => Belt_MutableQueue.add(pokemon.eventQueue, event));
}

function getMoveSlot(pokemon, index) {
  switch (index) {
    case 0 :
      return pokemon.moveSlot1;
    case 1 :
      return pokemon.moveSlot2;
    case 2 :
      return pokemon.moveSlot3;
    case 3 :
      return pokemon.moveSlot4;
    default:
      return;
  }
}

function processEvents(k, pokemon) {
  let $$break = false;
  while (!$$break) {
    let match = Belt_MutableQueue.pop(pokemon.eventQueue);
    if (match !== undefined) {
      switch (match.TAG) {
        case "MoveCast" :
          let moveIndex = match._0;
          let slot = getMoveSlot(pokemon, moveIndex);
          if (slot !== undefined) {
            slot.currentPP = slot.currentPP - 1 | 0;
            slot.lastUsedAt = k.time();
            pokemon.attackStatus = "CannotAttack";
            slot.move.cast(k, pokemon);
            delayedDispatch(k, pokemon, {
              TAG: "CooldownFinished",
              _0: moveIndex
            }, slot.move.coolDownDuration);
          }
          break;
        case "CooldownFinished" :
          let currentTime = k.time();
          let availableMoves = getAvailableMoveIndices(pokemon.moveSlot1, pokemon.moveSlot2, pokemon.moveSlot3, pokemon.moveSlot4, currentTime);
          pokemon.attackStatus = availableMoves;
          break;
        case "MobilityChanged" :
          pokemon.mobility = match._0;
          break;
      }
    } else {
      $$break = true;
    }
  };
}

function tryCastMove(pokemon, moveIndex) {
  let availableMoves = pokemon.attackStatus;
  if (availableMoves === "CannotAttack" || !availableMoves.includes(moveIndex)) {
    return;
  } else {
    return Belt_MutableQueue.add(pokemon.eventQueue, {
      TAG: "MoveCast",
      _0: moveIndex
    });
  }
}

function make(k, pokemonId, level, move1Opt, move2Opt, move3Opt, move4Opt, facing) {
  let move1 = move1Opt !== undefined ? move1Opt : ZeroMove$Skirmish.move;
  let move2 = move2Opt !== undefined ? move2Opt : ZeroMove$Skirmish.move;
  let move3 = move3Opt !== undefined ? move3Opt : ZeroMove$Skirmish.move;
  let move4 = move4Opt !== undefined ? move4Opt : ZeroMove$Skirmish.move;
  let moveSlot1 = PkmnMove$Skirmish.makeMoveSlot(move1);
  let moveSlot2 = PkmnMove$Skirmish.makeMoveSlot(move2);
  let moveSlot3 = PkmnMove$Skirmish.makeMoveSlot(move3);
  let moveSlot4 = PkmnMove$Skirmish.makeMoveSlot(move4);
  let match = facing === true ? [
      backSpriteName(pokemonId),
      k.Vec2.UP,
      k.height() * 0.75
    ] : [
      frontSpriteName(pokemonId),
      k.Vec2.DOWN,
      k.height() * 0.25
    ];
  let spriteName = match[0];
  let sprite = k.getSprite(spriteName).data;
  let match$1;
  if (sprite === null) {
    match$1 = [
      0,
      0
    ];
  } else {
    let halfSize = sprite.width / 2;
    let squaredPersonalSpace = halfSize * halfSize * halfSize;
    match$1 = [
      halfSize,
      squaredPersonalSpace
    ];
  }
  let currentTime = k.time();
  let initialAvailableMoves = getAvailableMoveIndices(moveSlot1, moveSlot2, moveSlot3, moveSlot4, currentTime);
  let gameObj = k.add([
    {
      direction: match[1],
      facing: facing,
      mobility: true,
      attackStatus: initialAvailableMoves,
      eventQueue: Belt_MutableQueue.make(),
      level: level,
      pokemonId: pokemonId,
      team: undefined,
      halfSize: match$1[0],
      squaredPersonalSpace: match$1[1],
      moveSlot1: moveSlot1,
      moveSlot2: moveSlot2,
      moveSlot3: moveSlot3,
      moveSlot4: moveSlot4
    },
    k.pos(k.center().x, match[2]),
    k.sprite(spriteName),
    k.area(),
    k.body(),
    k.health(20, 20),
    k.anchor("center"),
    k.opacity(1),
    k.animate(),
    Pokemon$Skirmish.tag,
    {
      id: "pokemon",
      drawInspect: function () {
        let gameObj = this ;
        let radius = Math.sqrt(gameObj.squaredPersonalSpace);
        k.drawCircle({
          opacity: 0.1,
          outline: {
            width: 2,
            color: k.MAGENTA
          },
          radius: radius
        });
      }
    }
  ]);
  gameObj.onHurt(_deltaHp => {
    gameObj.unanimate("opacity");
    let animation = gameObj.animation;
    animation.seek(0);
    gameObj.animate("opacity", [
      1,
      0.3,
      1,
      0.5,
      1
    ], {
      duration: 0.4,
      loops: 1
    });
  });
  gameObj.onDeath(() => {
    k.go(GameOver$Skirmish.sceneName, Stdlib_Option.getOrThrow(gameObj.team, undefined));
  });
  gameObj.onUpdate(() => processEvents(k, gameObj));
  return gameObj;
}

function assignPlayer(pokemon) {
  pokemon.team = true;
  pokemon.tag(Team$Skirmish.player);
}

function assignOpponent(pokemon) {
  pokemon.team = false;
  pokemon.tag(Team$Skirmish.opponent);
}

function getTeam(pokemon) {
  let team = pokemon.team;
  if (team !== undefined) {
    return team;
  } else {
    return Stdlib_JsError.throwWithMessage("Pokemon team not assigned");
  }
}

let movementSpeed = 200;

export {
  frontSpriteName,
  backSpriteName,
  frontSpriteUrl,
  backSpriteUrl,
  load,
  movementSpeed,
  getHealthPercentage,
  moveLeft,
  moveRight,
  getAvailableMoveIndices,
  dispatch,
  delayedDispatch,
  getMoveSlot,
  processEvents,
  tryCastMove,
  make,
  assignPlayer,
  assignOpponent,
  getTeam,
}
/* Pokemon-Skirmish Not a pure module */
