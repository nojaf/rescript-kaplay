// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Base from "./aux/Base.res.mjs";
import Kaplay from "kaplay";
import * as Z$Kaplay from "@nojaf/rescript-kaplay/src/Components/Z.res.mjs";
import * as Pos$Kaplay from "@nojaf/rescript-kaplay/src/Components/Pos.res.mjs";
import * as Area$Kaplay from "@nojaf/rescript-kaplay/src/Components/Area.res.mjs";
import * as Body$Kaplay from "@nojaf/rescript-kaplay/src/Components/Body.res.mjs";
import * as Move$Kaplay from "@nojaf/rescript-kaplay/src/Components/Move.res.mjs";
import * as Rect$Kaplay from "@nojaf/rescript-kaplay/src/Components/Rect.res.mjs";
import * as Color$Kaplay from "@nojaf/rescript-kaplay/src/Components/Color.res.mjs";
import * as Stdlib_Array from "rescript/lib/es6/Stdlib_Array.js";
import * as Anchor$Kaplay from "@nojaf/rescript-kaplay/src/Components/Anchor.res.mjs";
import * as Circle$Kaplay from "@nojaf/rescript-kaplay/src/Components/Circle.res.mjs";
import * as Health$Kaplay from "@nojaf/rescript-kaplay/src/Components/Health.res.mjs";
import * as Sprite$Kaplay from "@nojaf/rescript-kaplay/src/Components/Sprite.res.mjs";
import * as Context$Kaplay from "@nojaf/rescript-kaplay/src/Context.res.mjs";
import * as Opacity$Kaplay from "@nojaf/rescript-kaplay/src/Components/Opacity.res.mjs";
import * as OffScreen$Kaplay from "@nojaf/rescript-kaplay/src/Components/OffScreen.res.mjs";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as GameObjRaw$Kaplay from "@nojaf/rescript-kaplay/src/Components/GameObjRaw.res.mjs";

let k = Kaplay({
  width: 800,
  height: 400,
  background: "#f0f9ff",
  scale: Base.scale
});

let enemy = "enemy";

let bubble = "bubble";

let solidHeart = "solid-heart";

let Tags = {
  enemy: enemy,
  bubble: bubble,
  solidHeart: solidHeart
};

function circlePolygon(center, radius, segmentsOpt) {
  let segments = segmentsOpt !== undefined ? segmentsOpt : 32;
  let points = Stdlib_Array.fromInitializer(segments, idx => {
    let theta = idx / segments * 2 * Math.PI;
    return k.vec2(center.x + Math.cos(theta) * radius, center.y + Math.sin(theta) * radius);
  });
  return Context$Kaplay.mathPolygon(k, points);
}

function tryHeadOfMap(map) {
  return map.values().find(param => true);
}

Rect$Kaplay.Comp({});

Pos$Kaplay.Comp({});

Color$Kaplay.Comp({});

function make() {
  return k.add([
    k.rect(k.width(), 50),
    k.pos(0, 280),
    k.color(k.Color.fromHex("#cad5e2"))
  ]);
}

let Path = {
  make: make
};

GameObjRaw$Kaplay.Comp({});

Sprite$Kaplay.Comp({});

Pos$Kaplay.Comp({});

function make$1(x, y) {
  return [
    k.sprite("heart", {
      width: 10,
      height: 10
    }),
    k.pos(x, y),
    solidHeart
  ];
}

let Heart = {
  make: make$1
};

GameObjRaw$Kaplay.Comp({});

Sprite$Kaplay.Comp({});

Color$Kaplay.Comp({});

Pos$Kaplay.Comp({});

Area$Kaplay.Comp({});

Anchor$Kaplay.Comp({});

Move$Kaplay.Comp({});

OffScreen$Kaplay.Comp({});

Health$Kaplay.Comp({});

Opacity$Kaplay.Comp({});

function make$2() {
  let charmander = k.add([
    k.sprite("charmander", {
      height: 24,
      flipX: true
    }),
    k.color(k.Color.fromHex("#fe9441")),
    k.pos(0, 300),
    k.area(),
    k.anchor("center"),
    k.move(k.vec2(1, 0), 100),
    k.offscreen({
      destroy: true
    }),
    k.health(3),
    enemy
  ]);
  let hp = charmander.hp;
  for (let i = 1; i <= hp; ++i) {
    charmander.add(make$1(25 - i * 15, -35));
  }
  charmander.onHurt(param => {
    let tc = k.tween(1, 0.5, 0.1, opacity => {
      charmander.opacity = opacity;
    }, k.easings.linear);
    tc.onEnd(() => {
      k.tween(0.5, 1, 0.1, v => {
        charmander.opacity = v;
      }, k.easings.linear);
    });
  });
  charmander.onDeath(() => {
    k.destroy(charmander);
  });
  return charmander;
}

let Charmander = {
  make: make$2
};

Circle$Kaplay.Comp({});

Color$Kaplay.Comp({});

Opacity$Kaplay.Comp({});

Area$Kaplay.Comp({});

function make$3() {
  return [
    k.circle(200, {
      fill: true
    }),
    k.color(k.Color.fromHex("#D1FEB8")),
    k.opacity(0.2),
    k.area({
      shape: Primitive_option.some(circlePolygon(k.vec2(0, 0), 200, 32))
    }),
    {
      inSight: new Map()
    }
  ];
}

let Viewport = {
  make: make$3
};

Sprite$Kaplay.Comp({});

Anchor$Kaplay.Comp({});

Color$Kaplay.Comp({});

Z$Kaplay.Comp({});

function make$4() {
  return [
    k.sprite("squirtle", {
      height: 24,
      flipX: true
    }),
    k.anchor("center"),
    k.color(k.Color.fromHex("#00d3f2")),
    k.z(5)
  ];
}

let Squirtle = {
  make: make$4
};

GameObjRaw$Kaplay.Comp({});

Pos$Kaplay.Comp({});

Area$Kaplay.Comp({});

Z$Kaplay.Comp({});

Circle$Kaplay.Comp({});

Color$Kaplay.Comp({});

let bubbleColors = [
  k.Color.fromHex("#00bcff"),
  k.Color.fromHex("#a2f4fd"),
  k.Color.fromHex("#155dfc")
];

function make$5(homingVelocity, homingTimer) {
  let bubbleColor = bubbleColors[k.randi(0, 2)];
  return [
    k.pos(0, 0),
    k.color(bubbleColor),
    bubble,
    k.z(11),
    k.circle(k.rand(4, 6), {
      fill: true
    }),
    {
      homingTimer: homingTimer,
      homingVelocity: homingVelocity
    },
    k.area()
  ];
}

let Bubble = {
  bubbleColors: bubbleColors,
  make: make$5
};

GameObjRaw$Kaplay.Comp({});

Pos$Kaplay.Comp({});

Circle$Kaplay.Comp({});

Color$Kaplay.Comp({});

Body$Kaplay.Comp({});

function fireHomingBullet(tower, viewport, target) {
  let maxDistance = viewport.radius;
  let bulletSpeed = k.vec2(500);
  let homingVelocity = target.worldPos().sub(tower.worldPos()).unit().scale(bulletSpeed);
  let bubble = tower.add(make$5(homingVelocity, 0.2));
  bubble.onUpdate(() => {
    if (bubble.homingTimer > 0) {
      let toTarget = target.worldPos().sub(bubble.worldPos()).unit();
      bubble.homingVelocity = bubble.homingVelocity.lerp(toTarget.scale(bulletSpeed), 0.1);
      bubble.homingTimer = bubble.homingTimer - k.dt();
    }
    bubble.move(bubble.homingVelocity);
    if (bubble.worldPos().dist(tower.worldPos()) >= maxDistance) {
      bubble.destroy();
      return;
    }
    
  });
  bubble.onCollide(enemy, (enemy, param) => {
    bubble.destroy();
    enemy.hp = enemy.hp - 1 | 0;
    let heart = enemy.get(solidHeart).at(0);
    if (heart === undefined) {
      return;
    }
    let heart$1 = Primitive_option.valFromOption(heart);
    heart$1.play("empty");
    heart$1.untag(solidHeart);
  });
}

function make$6() {
  let tower = k.add([
    k.pos(k.width() / 2, 200),
    k.circle(30, {
      fill: true
    }),
    k.color(k.Color.fromHex("#cefafe")),
    k.body()
  ]);
  let viewport = tower.add(make$3());
  viewport.onCollide(enemy, (enemy, param) => {
    viewport.inSight.set(enemy.id, enemy);
  });
  viewport.onCollideEnd(enemy, enemy => {
    viewport.inSight.delete(enemy.id);
  });
  k.loop(0.5, () => {
    let enemy = viewport.inSight.values().find(param => true);
    if (enemy !== undefined) {
      return fireHomingBullet(tower, viewport, Primitive_option.valFromOption(enemy));
    }
    
  });
  tower.add(make$4());
  return tower;
}

let Tower = {
  fireHomingBullet: fireHomingBullet,
  make: make$6
};

function onSceneLoad() {
  make();
  make$6();
  k.loop(2.0, () => {
    make$2();
  });
}

k.loadSprite("charmander", import.meta.env.BASE_URL + "/sprites/charmander-rb.png");

k.loadSprite("squirtle", import.meta.env.BASE_URL + "/sprites/squirtle-rb.png");

k.loadSprite("heart", import.meta.env.BASE_URL + "/sprites/heart.png", {
  sliceX: 2,
  sliceY: 1,
  anims: {
    solid: {
      from: 0,
      to: 0
    },
    empty: {
      from: 1,
      to: 1
    }
  },
  anim: "solid"
});

k.onLoad(onSceneLoad);

export {
  k,
  Tags,
  circlePolygon,
  tryHeadOfMap,
  Path,
  Heart,
  Charmander,
  Viewport,
  Squirtle,
  Bubble,
  Tower,
  onSceneLoad,
}
/* k Not a pure module */
