// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Base from "./aux/Base.res.mjs";
import * as Menu from "./aux/Menu.res.mjs";
import Kaplay from "kaplay";
import * as Z$Kaplay from "@nojaf/rescript-kaplay/src/Components/Z.res.mjs";
import * as Pos$Kaplay from "@nojaf/rescript-kaplay/src/Components/Pos.res.mjs";
import * as Area$Kaplay from "@nojaf/rescript-kaplay/src/Components/Area.res.mjs";
import * as Body$Kaplay from "@nojaf/rescript-kaplay/src/Components/Body.res.mjs";
import * as Move$Kaplay from "@nojaf/rescript-kaplay/src/Components/Move.res.mjs";
import * as Rect$Kaplay from "@nojaf/rescript-kaplay/src/Components/Rect.res.mjs";
import * as Text$Kaplay from "@nojaf/rescript-kaplay/src/Components/Text.res.mjs";
import * as Color$Kaplay from "@nojaf/rescript-kaplay/src/Components/Color.res.mjs";
import * as Anchor$Kaplay from "@nojaf/rescript-kaplay/src/Components/Anchor.res.mjs";
import * as Rotate$Kaplay from "@nojaf/rescript-kaplay/src/Components/Rotate.res.mjs";
import * as Sprite$Kaplay from "@nojaf/rescript-kaplay/src/Components/Sprite.res.mjs";
import * as Outline$Kaplay from "@nojaf/rescript-kaplay/src/Components/Outline.res.mjs";
import * as OffScreen$Kaplay from "@nojaf/rescript-kaplay/src/Components/OffScreen.res.mjs";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as GameObjRaw$Kaplay from "@nojaf/rescript-kaplay/src/Components/GameObjRaw.res.mjs";

let k = Kaplay({
  width: 800,
  height: 400,
  global: false,
  background: "#cefafe",
  scale: Base.scale,
  crisp: true
});

let score = "score";

let gameOver = "gameOver";

let Events = {
  score: score,
  gameOver: gameOver
};

let score$1 = "score";

let die = "die";

let Sounds = {
  score: score$1,
  die: die
};

let menu = "menu";

let game = "flappy-bird";

let gameOver$1 = "gameOver";

let Scenes = {
  menu: menu,
  game: game,
  gameOver: gameOver$1
};

GameObjRaw$Kaplay.Comp({});

Pos$Kaplay.Comp({});

Sprite$Kaplay.Comp({});

Body$Kaplay.Comp({});

Color$Kaplay.Comp({});

Anchor$Kaplay.Comp({});

Area$Kaplay.Comp({});

Rotate$Kaplay.Comp({});

OffScreen$Kaplay.Comp({});

let tag = "bird";

let spriteName = "pidgeotto";

function make() {
  let bird = k.add([
    k.pos(k.center()),
    k.sprite(spriteName, {
      height: 35,
      flipX: true
    }),
    k.body(),
    k.color(k.Color.fromHex("#ffb86a")),
    k.anchor("center"),
    k.area(),
    k.rotate(0),
    k.offscreen({
      destroy: true
    }),
    tag
  ]);
  bird.onExitScreen(() => {
    bird.trigger(gameOver, undefined);
  });
  let fly = bird => {
    bird.jump(100);
    bird.rotateBy(-15);
    k.tween(-15, 0, 0.5, extra => {
      bird.angle = extra;
    });
  };
  k.onKeyRelease(key => {
    if (key === "space") {
      return fly(bird);
    }
    
  });
  k.onTouchEnd((param, param$1) => fly(bird));
  return bird;
}

let Bird = {
  tag: tag,
  spriteName: spriteName,
  make: make
};

GameObjRaw$Kaplay.Comp({});

Pos$Kaplay.Comp({});

Move$Kaplay.Comp({});

Area$Kaplay.Comp({});

OffScreen$Kaplay.Comp({});

Rect$Kaplay.Comp({});

Color$Kaplay.Comp({});

Outline$Kaplay.Comp({});

let tag$1 = "pipe";

function make$1(gap) {
  let x = k.width();
  let gapHeight = k.height() * gap;
  let remainingHeight = k.height() - gapHeight;
  let topPipeHeight = k.rand(0.20, 0.80) * remainingHeight;
  let bottomPipeHeight = remainingHeight - topPipeHeight;
  let topPipe = k.add([
    k.pos(x, 0),
    k.rect(40, topPipeHeight),
    k.color(k.Color.fromHex("#bbf451")),
    k.move(k.Vec2.LEFT, 200),
    k.offscreen({
      destroy: true
    }),
    k.area(),
    k.outline(3, k.Color.fromHex("#404040")),
    tag$1
  ]);
  let bottomPipe = k.add([
    k.pos(x, k.height() - bottomPipeHeight),
    k.rect(40, bottomPipeHeight),
    k.color(k.Color.fromHex("#bbf451")),
    k.move(k.Vec2.LEFT, 200),
    k.area(),
    k.outline(3, k.Color.fromHex("#404040")),
    tag$1
  ]);
  topPipe.onCollide(tag, (_bird, _collision) => {
    topPipe.trigger(gameOver, undefined);
  });
  bottomPipe.onCollide(tag, (_bird, _collision) => {
    bottomPipe.trigger(gameOver, undefined);
  });
  let ctrl = {
    contents: undefined
  };
  ctrl.contents = Primitive_option.some(topPipe.onUpdate(() => {
    if (topPipe.pos.x >= k.width() / 2) {
      return;
    }
    let ctrl$1 = ctrl.contents;
    if (ctrl$1 !== undefined) {
      Primitive_option.valFromOption(ctrl$1).cancel();
    }
    topPipe.trigger(score, 1);
  }));
}

let Pipes = {
  tag: tag$1,
  speed: 200,
  make: make$1
};

GameObjRaw$Kaplay.Comp({});

Pos$Kaplay.Comp({});

Color$Kaplay.Comp({});

Text$Kaplay.Comp({});

Anchor$Kaplay.Comp({});

Z$Kaplay.Comp({});

function make$2(text, x, y, anchorOpt) {
  let anchor = anchorOpt !== undefined ? anchorOpt : "center";
  return k.add([
    k.pos(x, y),
    k.color(k.Color.fromHex("#024a70")),
    k.text(text, {
      size: 24
    }),
    k.z(1),
    k.anchor(anchor)
  ]);
}

let Text = {
  make: make$2
};

function makeGameState() {
  return {
    score: 0,
    speed: 2.0,
    lastUpdate: 0,
    gap: 0.40
  };
}

function menu$1() {
  Menu.make(k, "Flappy Bird", [
    {
      label: "Play",
      action: () => {
        k.go(game);
      }
    },
    {
      label: "Play fullscreen",
      action: () => {
        k.setFullscreen(true);
        k.go(game);
      }
    }
  ], undefined, "#0069a8");
}

function game$1() {
  k.loadSprite(spriteName, import.meta.env.BASE_URL + "/sprites/pidgeotto-rb.png");
  k.loadSound(score$1, import.meta.env.BASE_URL + "/sounds/score.wav");
  k.loadSound(die, import.meta.env.BASE_URL + "/sounds/die.wav");
  k.setGravity(100);
  let gameState = {
    score: 0,
    speed: 2.0,
    lastUpdate: 0,
    gap: 0.40
  };
  let bird = make();
  let scoreText = make$2("Score: " + gameState.score.toString(), 25, 25, "topleft");
  let helpText = make$2("Press <space> to go up!", 25.0, k.height() - 25, "botleft");
  k.wait(2.5, () => {
    helpText.destroy();
  });
  k.on(score, tag$1, (_pipe, score$2) => {
    let birdIsColliding = bird.getCollisions().some(param => true);
    if (!birdIsColliding) {
      gameState.score = gameState.score + score$2 | 0;
      gameState.gap = gameState.gap - 0.02;
      scoreText.text = "Score: " + gameState.score.toString();
      k.play(score$1);
      return;
    }
    
  });
  k.on(gameOver, tag$1, (_pipe, param) => {
    k.play(die);
    k.go(gameOver$1, gameState.score);
  });
  make$1(gameState.gap);
  k.onUpdate(() => {
    gameState.lastUpdate = gameState.lastUpdate + k.dt();
    if (gameState.lastUpdate > gameState.speed) {
      make$1(gameState.gap);
      gameState.lastUpdate = 0;
      return;
    }
    
  });
}

function gameOver$2(score) {
  Menu.make(k, "Game Over", [
    {
      label: "Score: " + score.toString()
    },
    {
      label: "Replay",
      action: () => {
        k.go(game);
      }
    },
    {
      label: "Menu",
      action: () => {
        k.go(menu);
      }
    }
  ], undefined, "#0069a8");
}

k.scene(menu, menu$1);

k.scene(game, game$1);

k.scene(gameOver$1, gameOver$2);

k.go(menu);

export {
  k,
  Events,
  Sounds,
  Scenes,
  Bird,
  Pipes,
  Text,
  makeGameState,
  menu$1 as menu,
  game$1 as game,
  gameOver$2 as gameOver,
}
/* k Not a pure module */
