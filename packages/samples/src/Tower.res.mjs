// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Z$Kaplay from "@nojaf/rescript-kaplay/src/Components/Z.res.mjs";
import * as Pos$Kaplay from "@nojaf/rescript-kaplay/src/Components/Pos.res.mjs";
import * as Area$Kaplay from "@nojaf/rescript-kaplay/src/Components/Area.res.mjs";
import * as Body$Kaplay from "@nojaf/rescript-kaplay/src/Components/Body.res.mjs";
import * as GameContext from "./GameContext.res.mjs";
import * as Move$Kaplay from "@nojaf/rescript-kaplay/src/Components/Move.res.mjs";
import * as Rect$Kaplay from "@nojaf/rescript-kaplay/src/Components/Rect.res.mjs";
import * as Color$Kaplay from "@nojaf/rescript-kaplay/src/Components/Color.res.mjs";
import * as Stdlib_Array from "rescript/lib/es6/Stdlib_Array.js";
import * as Anchor$Kaplay from "@nojaf/rescript-kaplay/src/Components/Anchor.res.mjs";
import * as Circle$Kaplay from "@nojaf/rescript-kaplay/src/Components/Circle.res.mjs";
import * as Health$Kaplay from "@nojaf/rescript-kaplay/src/Components/Health.res.mjs";
import * as Sprite$Kaplay from "@nojaf/rescript-kaplay/src/Components/Sprite.res.mjs";
import * as Context$Kaplay from "@nojaf/rescript-kaplay/src/Context.res.mjs";
import * as Opacity$Kaplay from "@nojaf/rescript-kaplay/src/Components/Opacity.res.mjs";
import * as OffScreen$Kaplay from "@nojaf/rescript-kaplay/src/Components/OffScreen.res.mjs";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as GameObjRaw$Kaplay from "@nojaf/rescript-kaplay/src/Components/GameObjRaw.res.mjs";

let enemy = "enemy";

let bubble = "bubble";

let solidHeart = "solid-heart";

let Tags = {
  enemy: enemy,
  bubble: bubble,
  solidHeart: solidHeart
};

function circlePolygon(center, radius, segmentsOpt) {
  let segments = segmentsOpt !== undefined ? segmentsOpt : 32;
  let points = Stdlib_Array.fromInitializer(segments, idx => {
    let theta = idx / segments * 2 * Math.PI;
    return GameContext.k.vec2(center.x + Math.cos(theta) * radius, center.y + Math.sin(theta) * radius);
  });
  return Context$Kaplay.mathPolygon(GameContext.k, points);
}

function tryHeadOfMap(map) {
  return map.values().find(param => true);
}

Rect$Kaplay.Comp({});

Pos$Kaplay.Comp({});

Color$Kaplay.Comp({});

function make() {
  return GameContext.k.add([
    GameContext.k.rect(GameContext.k.width(), 100),
    GameContext.k.pos(0, 400),
    GameContext.k.color(GameContext.k.Color.fromHex("#cad5e2"))
  ]);
}

let Path = {
  make: make
};

GameObjRaw$Kaplay.Comp({});

Sprite$Kaplay.Comp({});

Pos$Kaplay.Comp({});

function make$1(x, y) {
  return [
    GameContext.k.sprite("heart", {
      width: 10,
      height: 10
    }),
    GameContext.k.pos(x, y),
    solidHeart
  ];
}

let Heart = {
  make: make$1
};

GameObjRaw$Kaplay.Comp({});

Sprite$Kaplay.Comp({});

Color$Kaplay.Comp({});

Pos$Kaplay.Comp({});

Area$Kaplay.Comp({});

Anchor$Kaplay.Comp({});

Move$Kaplay.Comp({});

OffScreen$Kaplay.Comp({});

Health$Kaplay.Comp({});

Opacity$Kaplay.Comp({});

function make$2() {
  let charmander = GameContext.k.add([
    GameContext.k.sprite("charmander", {
      height: 36,
      flipX: true
    }),
    GameContext.k.color(GameContext.k.Color.fromHex("#fe9441")),
    GameContext.k.pos(50, 450),
    GameContext.k.area(),
    GameContext.k.anchor("center"),
    GameContext.k.move(GameContext.k.vec2(1, 0), 100),
    GameContext.k.offscreen({
      destroy: true
    }),
    GameContext.k.health(3),
    enemy
  ]);
  let hp = charmander.hp();
  for (let i = 1; i <= hp; ++i) {
    charmander.add(make$1(25 - i * 15, -35));
  }
  charmander.onHurt(param => {
    let tc = GameContext.k.tween(1, 0.5, 0.1, opacity => {
      charmander.opacity = opacity;
    }, GameContext.k.easings.linear);
    tc.onEnd(() => {
      GameContext.k.tween(0.5, 1, 0.1, v => {
        charmander.opacity = v;
      }, GameContext.k.easings.linear);
    });
  });
  charmander.onDeath(() => {
    GameContext.k.destroy(charmander);
  });
  return charmander;
}

let Charmander = {
  make: make$2
};

Circle$Kaplay.Comp({});

Color$Kaplay.Comp({});

Opacity$Kaplay.Comp({});

Area$Kaplay.Comp({});

function make$3() {
  return [
    GameContext.k.circle(200, {
      fill: true
    }),
    GameContext.k.color(GameContext.k.Color.fromHex("#D1FEB8")),
    GameContext.k.opacity(0.2),
    GameContext.k.area({
      shape: Primitive_option.some(circlePolygon(GameContext.k.vec2(0, 0), 200, 32))
    }),
    {
      inSight: new Map()
    }
  ];
}

let Viewport = {
  make: make$3
};

Sprite$Kaplay.Comp({});

Anchor$Kaplay.Comp({});

Color$Kaplay.Comp({});

Z$Kaplay.Comp({});

function make$4() {
  return [
    GameContext.k.sprite("squirtle", {
      height: 36,
      flipX: true
    }),
    GameContext.k.anchor("center"),
    GameContext.k.color(GameContext.k.Color.fromHex("#00d3f2")),
    GameContext.k.z(5)
  ];
}

let Squirtle = {
  make: make$4
};

GameObjRaw$Kaplay.Comp({});

Pos$Kaplay.Comp({});

Area$Kaplay.Comp({});

Z$Kaplay.Comp({});

Circle$Kaplay.Comp({});

Color$Kaplay.Comp({});

let bubbleColors = [
  GameContext.k.Color.fromHex("#00bcff"),
  GameContext.k.Color.fromHex("#a2f4fd"),
  GameContext.k.Color.fromHex("#155dfc")
];

function make$5(homingVelocity, homingTimer) {
  let bubbleColor = bubbleColors[GameContext.k.randi(0, 2)];
  return [
    GameContext.k.pos(0, 0),
    GameContext.k.color(bubbleColor),
    bubble,
    GameContext.k.z(11),
    GameContext.k.circle(GameContext.k.rand(4, 6), {
      fill: true
    }),
    {
      homingTimer: homingTimer,
      homingVelocity: homingVelocity
    },
    GameContext.k.area()
  ];
}

let Bubble = {
  bubbleColors: bubbleColors,
  make: make$5
};

GameObjRaw$Kaplay.Comp({});

Pos$Kaplay.Comp({});

Circle$Kaplay.Comp({});

Color$Kaplay.Comp({});

Body$Kaplay.Comp({});

function fireHomingBullet(tower, viewport, target) {
  let maxDistance = viewport.radius;
  let bulletSpeed = GameContext.k.vec2(300);
  let homingVelocity = target.worldPos().sub(tower.worldPos()).unit().scale(bulletSpeed);
  let bubble = tower.add(make$5(homingVelocity, 0.2));
  bubble.onUpdate(() => {
    if (bubble.homingTimer > 0) {
      let toTarget = target.worldPos().sub(bubble.worldPos()).unit();
      bubble.homingVelocity = bubble.homingVelocity.lerp(toTarget.scale(bulletSpeed), 0.1);
      bubble.homingTimer = bubble.homingTimer - GameContext.k.dt();
    }
    bubble.move(bubble.homingVelocity);
    if (bubble.worldPos().dist(tower.worldPos()) >= maxDistance) {
      bubble.destroy();
      return;
    }
    
  });
  bubble.onCollide(enemy, (enemy, param) => {
    bubble.destroy();
    enemy.hurt(1);
    let heart = enemy.get(solidHeart).at(0);
    if (heart === undefined) {
      return;
    }
    let heart$1 = Primitive_option.valFromOption(heart);
    heart$1.play("empty");
    heart$1.untag(solidHeart);
  });
}

function make$6() {
  let tower = GameContext.k.add([
    GameContext.k.pos(GameContext.k.width() / 2, 320),
    GameContext.k.circle(30, {
      fill: true
    }),
    GameContext.k.color(GameContext.k.Color.fromHex("#cefafe")),
    GameContext.k.body()
  ]);
  let viewport = tower.add(make$3());
  viewport.onCollide(enemy, (enemy, param) => {
    viewport.inSight.set(enemy.id, enemy);
  });
  viewport.onCollideEnd(enemy, enemy => {
    viewport.inSight.delete(enemy.id);
  });
  GameContext.k.loop(0.5, () => {
    let enemy = viewport.inSight.values().find(param => true);
    if (enemy !== undefined) {
      return fireHomingBullet(tower, viewport, Primitive_option.valFromOption(enemy));
    }
    
  });
  tower.add(make$4());
  return tower;
}

let Tower = {
  fireHomingBullet: fireHomingBullet,
  make: make$6
};

function onSceneLoad() {
  make();
  make$6();
  GameContext.k.loop(2.0, () => {
    make$2();
  });
}

function scene() {
  GameContext.k.loadSprite("charmander", "/sprites/charmander-rb.png");
  GameContext.k.loadSprite("squirtle", "/sprites/squirtle-rb.png");
  GameContext.k.loadSprite("heart", "/sprites/heart.png", {
    sliceX: 2,
    sliceY: 1,
    anims: {
      solid: {
        from: 0,
        to: 0
      },
      empty: {
        from: 1,
        to: 1
      }
    },
    anim: "solid"
  });
  GameContext.k.onLoad(onSceneLoad);
}

export {
  Tags,
  circlePolygon,
  tryHeadOfMap,
  Path,
  Heart,
  Charmander,
  Viewport,
  Squirtle,
  Bubble,
  Tower,
  onSceneLoad,
  scene,
}
/*  Not a pure module */
