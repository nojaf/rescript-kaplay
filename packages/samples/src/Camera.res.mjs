// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Base from "./aux/Base.res.mjs";
import Kaplay from "kaplay";
import * as Pos$Kaplay from "@nojaf/rescript-kaplay/src/Components/Pos.res.mjs";
import * as Area$Kaplay from "@nojaf/rescript-kaplay/src/Components/Area.res.mjs";
import * as Text$Kaplay from "@nojaf/rescript-kaplay/src/Components/Text.res.mjs";
import * as Color$Kaplay from "@nojaf/rescript-kaplay/src/Components/Color.res.mjs";
import * as Sprite$Kaplay from "@nojaf/rescript-kaplay/src/Components/Sprite.res.mjs";
import * as GameObjRaw$Kaplay from "@nojaf/rescript-kaplay/src/Components/GameObjRaw.res.mjs";

let k = Kaplay({
  width: 800,
  height: 400,
  background: "#f54900",
  scale: Base.scale,
  crisp: true
});

let gameWidth = k.width();

let gameHeight = k.height();

let cameraBounds = {
  x: {
    min: gameWidth / 2,
    max: 1000 - gameWidth / 2
  },
  y: {
    min: gameHeight / 2,
    max: 563 - gameHeight / 2
  }
};

let zeroVector = k.vec2(0, 0);

let cameraVelocity = {
  contents: zeroVector
};

let lastTouchStart = {
  contents: zeroVector
};

let isDragging = {
  contents: false
};

function updateCamera(result) {
  let currentCamPos = k.getCamPos();
  let result$1 = currentCamPos.add(result);
  result$1.x = k.clamp(result$1.x, cameraBounds.x.min, cameraBounds.x.max);
  result$1.y = k.clamp(result$1.y, cameraBounds.y.min, cameraBounds.y.max);
  k.tween(currentCamPos, result$1, 0.100, v => {
    k.setCamPos(v);
  }, k.easings.linear);
}

GameObjRaw$Kaplay.Comp({});

Pos$Kaplay.Comp({});

Text$Kaplay.Comp({});

Color$Kaplay.Comp({});

function make(x, y, text) {
  return k.add([
    k.pos(x, y),
    k.text(text, {
      size: 20
    }),
    k.color(k.Color.fromHex("#ffe62d"))
  ]);
}

let Text = {
  make: make
};

GameObjRaw$Kaplay.Comp({});

Pos$Kaplay.Comp({});

Sprite$Kaplay.Comp({});

Area$Kaplay.Comp({});

function make$1() {
  return k.add([
    k.pos(0, 0),
    k.sprite("bg", {
      width: 1000,
      height: 563
    }),
    k.area()
  ]);
}

let $$Map = {
  make: make$1
};

function onLoad() {
  let map = make$1();
  k.onTouchStart((pos, _touch) => {
    lastTouchStart.contents = pos;
    isDragging.contents = true;
    cameraVelocity.contents = zeroVector;
  });
  k.onTouchMove((pos, _touch) => {
    if (!isDragging.contents) {
      return;
    }
    let delta = pos.sub(lastTouchStart.contents);
    cameraVelocity.contents = delta.scale(k.vec2(-150, -100));
    lastTouchStart.contents = pos;
  });
  k.onTouchEnd((param, _touch) => {
    isDragging.contents = false;
  });
  k.onUpdate(() => {
    if (isDragging.contents) {
      return;
    }
    let currentVelocity = cameraVelocity.contents;
    if (currentVelocity.len() > 0.1) {
      updateCamera(currentVelocity);
      cameraVelocity.contents = currentVelocity.scale(k.vec2(0.9, 0.9));
      return;
    }
    
  });
  map.onKeyDown(key => {
    let currentCamPos = k.getCamPos();
    let move;
    switch (key) {
      case "left" :
        move = k.vec2(- 10, 0);
        break;
      case "right" :
        move = k.vec2(10, 0);
        break;
      case "up" :
        move = k.vec2(0, - 10);
        break;
      case "down" :
        move = k.vec2(0, 10);
        break;
      case "space" :
      case "enter" :
        move = k.vec2(0, 0);
        break;
    }
    let result = currentCamPos.add(move);
    result.x = k.clamp(result.x, cameraBounds.x.min, cameraBounds.x.max);
    result.y = k.clamp(result.y, cameraBounds.y.min, cameraBounds.y.max);
    k.setCamPos(result);
  });
  make(15, k.height() - 30, "Press arrow keys or touch to move the camera");
}

k.loadSprite("bg", import.meta.env.BASE_URL + "/sprites/middle-earth.webp");

k.onLoad(onLoad);

let speed = 10;

let mapWidth = 1000;

let mapHeight = 563;

export {
  k,
  speed,
  mapWidth,
  mapHeight,
  gameWidth,
  gameHeight,
  cameraBounds,
  zeroVector,
  cameraVelocity,
  lastTouchStart,
  isDragging,
  updateCamera,
  Text,
  $$Map,
  onLoad,
}
/* k Not a pure module */
