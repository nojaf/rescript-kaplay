// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Pos$Kaplay from "@nojaf/rescript-kaplay/src/Components/Pos.res.mjs";
import * as Area$Kaplay from "@nojaf/rescript-kaplay/src/Components/Area.res.mjs";
import * as GameContext from "./GameContext.res.mjs";
import * as Sprite$Kaplay from "@nojaf/rescript-kaplay/src/Components/Sprite.res.mjs";
import * as GameObjRaw$Kaplay from "@nojaf/rescript-kaplay/src/Components/GameObjRaw.res.mjs";

let gameWidth = GameContext.k.width();

let gameHeight = GameContext.k.height();

let cameraBounds = {
  x: {
    min: gameWidth / 2,
    max: 1000 - gameWidth / 2
  },
  y: {
    min: gameHeight / 2,
    max: 563 - gameHeight / 2
  }
};

let zeroVector = GameContext.k.vec2(0, 0);

let cameraVelocity = {
  contents: zeroVector
};

let lastTouchStart = {
  contents: zeroVector
};

let isDragging = {
  contents: false
};

function updateCamera(result) {
  let currentCamPos = GameContext.k.getCamPos();
  let result$1 = currentCamPos.add(result);
  result$1.x = GameContext.k.clampFloat(result$1.x, cameraBounds.x.min, cameraBounds.x.max);
  result$1.y = GameContext.k.clampFloat(result$1.y, cameraBounds.y.min, cameraBounds.y.max);
  GameContext.k.tween(currentCamPos, result$1, 0.100, v => {
    GameContext.k.setCamPos(v);
  }, GameContext.k.easings.linear);
}

GameObjRaw$Kaplay.Comp({});

Pos$Kaplay.Comp({});

Sprite$Kaplay.Comp({});

Area$Kaplay.Comp({});

function make() {
  return GameContext.k.add([
    GameContext.k.pos(0, 0),
    GameContext.k.sprite("bg", {
      width: 1000,
      height: 563
    }),
    GameContext.k.area()
  ]);
}

let $$Map = {
  make: make
};

function scene() {
  GameContext.k.loadSprite("bg", import.meta.env.BASE_URL + "/sprites/middle-earth.webp");
  let map = make();
  GameContext.k.onTouchStart((pos, _touch) => {
    lastTouchStart.contents = pos;
    isDragging.contents = true;
    cameraVelocity.contents = zeroVector;
  });
  GameContext.k.onTouchMove((pos, _touch) => {
    if (!isDragging.contents) {
      return;
    }
    let delta = pos.sub(lastTouchStart.contents);
    cameraVelocity.contents = delta.scale(GameContext.k.vec2(-150, -100));
    lastTouchStart.contents = pos;
  });
  GameContext.k.onTouchEnd((param, _touch) => {
    isDragging.contents = false;
  });
  GameContext.k.onUpdate(() => {
    if (isDragging.contents) {
      return;
    }
    let currentVelocity = cameraVelocity.contents;
    if (currentVelocity.len() > 0.1) {
      updateCamera(currentVelocity);
      cameraVelocity.contents = currentVelocity.scale(GameContext.k.vec2(0.9, 0.9));
      return;
    }
    
  });
  map.onKeyDown(key => {
    let currentCamPos = GameContext.k.getCamPos();
    let move;
    switch (key) {
      case "left" :
        move = GameContext.k.vec2(- 10, 0);
        break;
      case "right" :
        move = GameContext.k.vec2(10, 0);
        break;
      case "up" :
        move = GameContext.k.vec2(0, - 10);
        break;
      case "down" :
        move = GameContext.k.vec2(0, 10);
        break;
      case "space" :
      case "enter" :
        move = GameContext.k.vec2(0, 0);
        break;
    }
    let result = currentCamPos.add(move);
    result.x = GameContext.k.clampFloat(result.x, cameraBounds.x.min, cameraBounds.x.max);
    result.y = GameContext.k.clampFloat(result.y, cameraBounds.y.min, cameraBounds.y.max);
    GameContext.k.setCamPos(result);
  });
}

let speed = 10;

let mapWidth = 1000;

let mapHeight = 563;

export {
  speed,
  mapWidth,
  mapHeight,
  gameWidth,
  gameHeight,
  cameraBounds,
  zeroVector,
  cameraVelocity,
  lastTouchStart,
  isDragging,
  updateCamera,
  $$Map,
  scene,
}
/* gameWidth Not a pure module */
