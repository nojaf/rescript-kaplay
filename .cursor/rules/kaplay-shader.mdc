## Kaplay shaders - focused quick reference

- Loading and applying
  - Load once: `k->loadShader("name", ~frag=source)`
  - Apply in `Context.add`: include `addShader(k, "name", ~uniform=() => {...})` in the component list
  - Apply after creation: `obj->use(addShader(k, "name", ~uniform=() => {...}))`
  - `~uniform` returns a record of uniforms; omit `()` on `@send` methods unless passing labeled args.

- Uniform types
  - Floats: `float`
  - Vec2: `k->vec2(w, h)`
  - Color: pass Kaplay color `{r:int, g:int, b:int}` (or `k->Color.*`, `k->Color.fromHex("#rrggbb")`); in GLSL convert via `u_color / 255.0` (GLSL expects 0–1).

- Resolution, scale, atlas
  - Pixel-accurate effects need intrinsic pixel size in `u_resolution` (e.g., `32x32`), not world size.
  - `~options={singular: true}` on `loadSprite` avoids atlas bleeding; it does not affect shader math.
  - `crisp: true` in `kaplay(~initOptions)` helps keep edges sharp.

- Alpha thresholding
  - For pixel-art, use a higher cut like `ALPHA_THRESHOLD = 0.7` to ignore semi‑transparent edge pixels.

- Example: outline shader usage from ReScript

```rescript
// Load
k->loadShader("outline2px", ~frag=outline2pxSource)

// Apply
gameObj->use(addShader(k, "outline2px", ~uniform=() => {
  "u_resolution": k->vec2(32., 32.), // intrinsic pixels or asset size
  "u_color": k->Color.cyan,
}))
```

- Parameter mapping (ReScript -> GLSL)

| Uniform         | GLSL type | ReScript value                                    | Notes                                   |
|-----------------|-----------|---------------------------------------------------|-----------------------------------------|
| `u_time`        | float     | `k->time`                                         | seconds since start                     |
| `u_resolution`  | vec2      | `k->vec2(widthPx, heightPx)` (e.g., 32., 32.)     | intrinsic pixel size of the sprite      |
| `u_thickness`   | float     | small float in pixels (e.g., 0.7..3.)             | ring center radius in texels            |
| `u_color`       | vec3      | Kaplay color (e.g., `k->Color.cyan` or fromHex)   | divide by 255.0 in the shader           |
| `u_intensity`   | float     | 0.0..1.0 (typical)                                 | overall alpha multiplier                 |
| `u_pulse_speed` | float     | 1.0..10.0 (typical)                                | higher = faster breathing animation     |

- Example fragments used here

darken.frag (debug silhouette)
```glsl
vec4 frag(vec2 pos, vec2 uv, vec4 color, sampler2D tex) {
  const float ALPHA_THRESHOLD = 0.7;
  vec4 src = texture2D(tex, uv);
  return src.a > ALPHA_THRESHOLD ? vec4(0.0, 0.0, 0.0, 1.0) : src;
}
```

outline2px.frag (2px contour ring)
```glsl
uniform vec2 u_resolution;  // sprite pixel size, e.g. 32x32
uniform vec3 u_color;       // Kaplay color 0–255

vec4 frag(vec2 pos, vec2 uv, vec4 color, sampler2D tex) {
  const float ALPHA_THRESHOLD = 0.7;
  const float PI = 3.14159265359;
  const int SAMPLE_DIRECTIONS = 8; // raise for smoother curves

  vec4 src = texture2D(tex, uv);
  if (src.a > ALPHA_THRESHOLD) return src;

  vec2 texel = 1.0 / u_resolution;
  float minDistance = 10.0;
  for (int p = 1; p <= 2; p++) {
    float r = float(p);
    for (int i = 0; i < SAMPLE_DIRECTIONS; i++) {
      float a = float(i) * (2.0 * PI) / float(SAMPLE_DIRECTIONS);
      vec2 dir = vec2(cos(a), sin(a));
      vec2 sampleUV = uv + dir * texel * r;
      if (sampleUV.x >= 0.0 && sampleUV.x <= 1.0 &&
          sampleUV.y >= 0.0 && sampleUV.y <= 1.0) {
        if (texture2D(tex, sampleUV).a > ALPHA_THRESHOLD) {
          minDistance = min(minDistance, r);
        }
      }
    }
  }

  if (minDistance <= 2.0) return vec4(u_color / 255.0, 1.0);
  return src;
}
```

- glow.frag (animated ring)
```glsl
// Inputs: u_time, u_resolution, u_thickness, u_color(0-255), u_intensity, u_pulse_speed
// Output: animated ring band that breathes around the sprite contour
```

- Troubleshooting
  - Jagged ring: increase `SAMPLE_DIRECTIONS` to 16/24.
  - Thickness shifts with scaling: ensure `u_resolution` is intrinsic pixels, not world size.
  - Color mismatch: pass a Kaplay color and divide by 255 in GLSL.
  - Edge bleeding: prefer `~options={singular: true}` when loading the sprite.
```
