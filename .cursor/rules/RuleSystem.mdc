# RuleSystem - Rule-Based AI System for KAPLAY

## Overview

The `RuleSystem` is a powerful rule-based AI system that allows you to create intelligent behaviors using a pattern of "if-then" rules. It's perfect for implementing decision-making logic, state management, and AI behaviors in your KAPLAY games.

The system works by evaluating rules against a set of facts. When a rule's condition (predicate) is true, it executes its action. Facts are stored with a grade (0 to 1), allowing you to represent confidence levels or fuzzy logic.

## Getting Started

To use `RuleSystem`, you first need to create an instance. It's available through the KAPLAY context:

```rescript
open Kaplay

let k = Context.kaplay()

// Create a new rule system
let ai = RuleSystem.make(k)
```

## Core Concepts

### Facts

Facts are pieces of information stored in the system. Each fact has a name (string) and a grade (number between 0 and 1). The grade represents the strength or confidence of the fact.

- **Grade 0**: The fact is not true (or has no confidence)
- **Grade 1**: The fact is fully true (or has maximum confidence)
- **Grades between 0 and 1**: Partial truth or confidence levels

### Rules

Rules define the behavior of your AI system. Each rule has:
- **Predicate**: A condition that evaluates to true or false
- **Action**: What happens when the predicate is true
- **Salience**: Priority level (lower numbers execute first)

### Execution Flow

When you call `execute()`, the system:
1. Sorts all rules by salience (ascending order)
2. Evaluates each rule's predicate
3. Executes the action for rules where the predicate is true

## Basic Usage

### Creating a Simple Rule

Here's a basic example that demonstrates the core workflow:

```rescript
open Kaplay

let k = Context.kaplay()

type gameState = {mutable health: int}

let ai = RuleSystem.make(k)

// Set initial state
ai.state = {health: 50}

// Add a rule that executes an action when a condition is met
ai->RuleSystem.addRuleExecutingAction(
  // Predicate: when player health is low
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.health < 30
  },
  // Action: heal the player
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.health = state.health + 20
    Console.log("Healing player!")
  },
  ~salient=Salience(0.0), // Salience (priority)
)

// When health < 30, the rule executes and heals the player
```

### Working with Facts

Facts allow you to build more complex decision-making systems:

```rescript
open Kaplay

let k = Context.kaplay()
let ai = RuleSystem.make(k)

// Assert some facts
ai->RuleSystem.assertFact(Fact("playerNearby"), ~grade=Grade(0.8))  // 80% confidence player is nearby
ai->RuleSystem.assertFact(Fact("lowHealth"), ~grade=Grade(1.0))     // 100% confidence health is low
ai->RuleSystem.assertFact(Fact("hasAmmo"), ~grade=Grade(0.5))        // 50% confidence we have ammo

// Check fact grades
switch ai->RuleSystem.gradeForFact(Fact("playerNearby")) {
| Grade(g) => Console.log(g) // 0.8
}
```

### Rules with Facts

You can create rules that check facts and assert or retract other facts:

```rescript
open Kaplay

let k = Context.kaplay()
let ai = RuleSystem.make(k)

// Rule: If player is nearby and we have low health, assert "shouldRetreat"
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<'state>) => {
    switch (rs->RuleSystem.gradeForFact(Fact("playerNearby")), rs->RuleSystem.gradeForFact(Fact("lowHealth"))) {
    | (Grade(pn), Grade(lh)) => pn > 0.7 && lh > 0.8
    | _ => false
    }
  },
  Fact("shouldRetreat"),  // Fact to assert
  ~grade=Grade(1.0),      // Grade to assert with
)

// When both facts are true, "shouldRetreat" is asserted
```

### Retracting Facts

You can also create rules that retract (reduce the grade of) facts:

```rescript
open Kaplay

let k = Context.kaplay()

type gameState = {mutable distanceToPlayer: float}

let ai = RuleSystem.make(k)

// Rule: If player moves away, retract "playerNearby"
ai->RuleSystem.addRuleRetractingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.distanceToPlayer > 100.0
  },
  Fact("playerNearby"),  // Fact to retract
  ~grade=Grade(0.5),     // Grade to retract by
)

// When distance > 100, the fact's grade is reduced by 0.5
```

> **Important**: See the section on [Understanding Assert/Retract Pairs](#understanding-assertretract-pairs) below for guidance on when you need to pair assert and retract rules together.

### Understanding Assert/Retract Pairs

An important design consideration when using `addRuleAssertingFact` and `addRuleRetractingFact` is whether you need them in pairs. The answer depends on your use case:

**Key Point**: Facts persist until explicitly retracted or reset. When a rule's predicate becomes false, the fact it asserted remains at its current grade unless another rule retracts it.

#### When You Need Pairs (Mutually Exclusive States)

For facts that represent **current state** or **mutually exclusive conditions**, you should use pairs to ensure facts accurately reflect reality:

```rescript
open Kaplay

let k = Context.kaplay()

type gameState = {mutable playerDistance: float}

let ai = RuleSystem.make(k)

// Assert "playerFar" when distance > 10
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.playerDistance > 10.0
  },
  Fact("playerFar"),
  ~grade=Grade(1.0),
)

// Retract "playerFar" when distance <= 10 (the opposite condition)
ai->RuleSystem.addRuleRetractingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.playerDistance <= 10.0
  },
  Fact("playerFar"),
  ~grade=Grade(1.0),
)

// Now "playerFar" accurately reflects current state
// When distance > 10: grade = 1.0
// When distance <= 10: grade = 0.0
```

**Why pairs matter here**: Without the retract rule, once `playerFar` is asserted, it would remain true even when the player gets close, leading to incorrect behavior.

#### When You Don't Need Pairs (Accumulating Evidence)

For facts that represent **accumulating evidence**, **events**, or **persistent knowledge**, you typically don't need retract rules:

```rescript
open Kaplay

let k = Context.kaplay()

type gameState = {mutable hasLineOfSight: bool}

let ai = RuleSystem.make(k)

// Assert "playerSeen" when player is visible
// This fact persists - once seen, always "seen" (until reset)
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.hasLineOfSight
  },
  Fact("playerSeen"),
  ~grade=Grade(1.0),
)

// No retract rule needed - "playerSeen" is a persistent fact
// It represents historical knowledge, not current state
```

**When to use this pattern**: 
- Historical events ("enemyAttacked", "keyCollected")
- Accumulated evidence ("suspiciousActivity")
- Persistent states that should remain until explicitly cleared

#### The Twofold Pattern

For facts representing **current conditions**, use the twofold pattern where each assertion has a corresponding retraction with the opposite condition:

```rescript
open Kaplay

let k = Context.kaplay()

type gameState = {mutable health: int}

let ai = RuleSystem.make(k)

// Pattern: Assert when condition is true
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.health < 30
  },
  Fact("lowHealth"),
  ~grade=Grade(1.0),
)

// Pattern: Retract when condition is false (opposite)
ai->RuleSystem.addRuleRetractingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.health >= 30
  },
  Fact("lowHealth"),
  ~grade=Grade(1.0),
)

// This ensures "lowHealth" always reflects current reality
```

**Best Practice**: When a fact represents a **current state** (like "playerFar", "lowHealth", "inCombat"), use the twofold pattern. When it represents **historical knowledge** or **accumulated evidence**, you typically don't need pairs.

#### Handling Multiple Sources

Sometimes multiple rules can assert the same fact. In these cases, you might want selective retraction:

```rescript
open Kaplay

let k = Context.kaplay()

type gameState = {mutable health: int, mutable enemyCount: int}

let ai = RuleSystem.make(k)

// Source 1: Assert "danger" when health is low
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.health < 20
  },
  Fact("danger"),
  ~grade=Grade(0.5),  // Partial grade
)

// Source 2: Assert "danger" when enemies nearby
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.enemyCount > 3
  },
  Fact("danger"),
  ~grade=Grade(0.5),  // Partial grade
)

// Retract only when BOTH conditions are false
ai->RuleSystem.addRuleRetractingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.health >= 20 && state.enemyCount <= 3
  },
  Fact("danger"),
  ~grade=Grade(1.0),  // Full retraction
)

// Now "danger" can be 0.0, 0.5, or 1.0 depending on conditions
```

#### Common Pitfall: Forgetting Retract Rules

A common mistake is asserting facts without corresponding retracts for state-based facts:

```rescript
// ❌ PROBLEMATIC: Fact persists even when condition becomes false
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.playerDistance > 10.0
  },
  Fact("playerFar"),
  ~grade=Grade(1.0),
)
// Missing: retract rule for when distance <= 10

// ✅ CORRECT: Twofold pattern ensures accuracy
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.playerDistance > 10.0
  },
  Fact("playerFar"),
  ~grade=Grade(1.0),
)
ai->RuleSystem.addRuleRetractingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.playerDistance <= 10.0
  },
  Fact("playerFar"),
  ~grade=Grade(1.0),
)
```

#### Summary: When to Use Pairs

| Use Case | Need Pair? | Example |
|----------|------------|---------|
| Current state facts | ✅ Yes | "playerFar", "lowHealth", "inCombat" |
| Historical events | ❌ No | "playerSeen", "keyCollected" |
| Accumulated evidence | ❌ No | "suspiciousActivity" |
| Temporary conditions | ✅ Yes | "underAttack", "nearGoal" |
| Persistent knowledge | ❌ No | "hasVisitedArea", "knowsSecret" |

**Rule of thumb**: If the fact should **automatically become false** when conditions change, use a pair. If the fact represents **something that happened** or **knowledge gained**, you typically don't need a retract rule.

## Salience and Rule Execution Order

Salience controls the order in which rules execute. This is fundamental to how the rule system works, not just an advanced feature. Understanding salience is crucial for building systems where facts depend on other facts.

### How Salience Works

Rules are sorted by salience in **ascending order** (lower values execute first). When `execute()` is called:

1. All rules are sorted by salience (ascending)
2. Each rule's predicate is evaluated
3. Rules with true predicates execute their actions

**Key Point**: Facts asserted by rules at lower salience values are **immediately available** to rules at higher salience values in the same execution cycle.

### Basic Priority Control

You can use salience to control execution order:

```rescript
open Kaplay

let k = Context.kaplay()

type gameState = {mutable health: int, mutable alive: bool}

let ai = RuleSystem.make(k)

// High priority rule (executes first)
ai->RuleSystem.addRuleExecutingAction(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.health <= 0
  },
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    Console.log("Player died!")
    state.alive = false
  },
  ~salient=Salience(-10.0), // Low salience = high priority
)

// Lower priority rule
ai->RuleSystem.addRuleExecutingAction(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.health < 50
  },
  (rs: RuleSystem.t<gameState>) => {
    Console.log("Health is low")
  },
  ~salient=Salience(10.0), // Higher salience = lower priority
)

// Rules execute in salience order: -10.0 first, then 10.0
```

### Fact Dependencies and Salience

The most powerful use of salience is creating **fact dependencies**: rules that compute facts from other facts. Facts asserted at lower salience are available to rules at higher salience.

```rescript
open Kaplay

let k = Context.kaplay()

module Salience = {
  // Tier 1: Base facts computed from game state (no dependencies)
  let baseFacts = Salience(0.0)
  
  // Tier 2: Derived facts that depend on base facts
  let derivedFacts = Salience(10.0)
  
  // Tier 3: Decision/action rules that depend on all facts
  let decisions = Salience(20.0)
}

// Tier 1: Base facts (salience 0.0) - computed from game state
ai->RuleSystem.addRuleAssertingFact(
  rs => rs.state.attackX < rs.state.enemyX,
  Fact("attackFromLeft"),
  ~grade=Grade(1.0),
  ~salient=Salience.baseFacts,
)

// Tier 2: Derived fact (salience 10.0) - can read base facts
ai->RuleSystem.addRuleAssertingFact(
  rs => {
    // ✅ Can read attackFromLeft because it was asserted at salience 0.0
    switch RuleSystem.gradeForFact(rs, Fact("attackFromLeft")) {
    | Grade(g) => g > 0.0
    | _ => false
    }
  },
  Fact("safeToMoveRight"),
  ~grade=Grade(1.0),
  ~salient=Salience.derivedFacts, // Executes AFTER base facts
)
```

**Important**: Facts are stored in a mutable map that's updated immediately when rules execute. This means:
- Rules at salience 0.0 can assert facts
- Rules at salience 10.0 can read those facts in the same `execute()` call
- Rules at salience 20.0 can read both base and derived facts

### Recommended Salience Strategy

Use a tiered approach with clear separation:

```rescript
module Salience = {
  let baseFacts = Salience(0.0)      // Facts from game state
  let derivedFacts = Salience(10.0)   // Facts from other facts
  let decisions = Salience(20.0)      // Actions based on facts
}
```

This makes dependencies explicit and ensures facts are computed in the correct order.

## Fact Decomposition

Complex facts that encode too much information can lead to complex branching logic in action handlers. Breaking them down into smaller, focused facts makes the system more declarative and easier to reason about.

### The Problem: Too Broad Facts

Consider a fact like `attackIncoming` that only tells you "there's an attack" but doesn't encode:
- **Where** the attack is relative to the enemy
- **Which directions** are safe to move
- **How much space** is available

This forces action handlers to compute these at runtime, leading to complex if/else chains:

```rescript
// ❌ PROBLEMATIC: Too much logic in action handler
switch RuleSystem.gradeForFact(rs, Fact("attackIncoming")) {
| Grade(g) when g > 0.0 => {
    // Complex runtime computation
    let (attackOnLeft, attackOnRight) = verifyAttacks(rs)
    if attackOnLeft {
      moveRight()
    } else if attackOnRight {
      moveLeft()
    } else {
      // More complex space calculations...
    }
  }
| _ => ()
}
```

### The Solution: Decompose into Focused Facts

Break down the broad fact into smaller, focused facts:

**Positional Facts** (describe where things are):
- `attackFromLeft` - Attack exists to the left
- `attackFromRight` - Attack exists to the right
- `attackAligned` - Attack is aligned (same X position)

**Space Facts** (describe available space):
- `moreSpaceOnLeft` - Space available on left (graded 0.0-1.0)
- `moreSpaceOnRight` - Space available on right (graded 0.0-1.0)

**Derived Facts** (computed from other facts):
- `safeToMoveLeft` - Safe to move left (derived from attack and space facts)
- `safeToMoveRight` - Safe to move right (derived from attack and space facts)

### Example: Refactoring with Fact Decomposition

```rescript
// Base facts: Positional information (salience 0.0)
ai->RuleSystem.addRuleAssertingFact(
  rs => rs.state.attackX < rs.state.enemyX,
  Fact("attackFromLeft"),
  ~grade=Grade(1.0),
  ~salient=Salience(0.0),
)

// Base facts: Space availability (graded for continuous values)
ai->RuleSystem.addRuleExecutingAction(
  rs => true,
  rs => {
    let grade = calculateSpaceGrade(rs.state)
    rs->RuleSystem.assertFact(Fact("moreSpaceOnLeft"), ~grade=Grade(grade))
  },
  ~salient=Salience(0.0),
)

// Derived facts: Safety (salience 10.0 - depends on base facts)
ai->RuleSystem.addRuleAssertingFact(
  rs => {
    // ✅ Can read base facts because they were asserted at salience 0.0
    switch (
      RuleSystem.gradeForFact(rs, Fact("attackFromRight")),
      RuleSystem.gradeForFact(rs, Fact("moreSpaceOnLeft")),
    ) {
    | (Grade(attackR), Grade(spaceL)) => attackR == 0.0 && spaceL > 0.3
    | _ => false
    }
  },
  Fact("safeToMoveLeft"),
  ~grade=Grade(1.0),
  ~salient=Salience(10.0), // Executes AFTER base facts
)

// Action handler becomes declarative (salience 20.0)
ai->RuleSystem.addRuleExecutingAction(
  rs => {
    switch RuleSystem.gradeForFact(rs, Fact("safeToMoveLeft")) {
    | Grade(g) => g > 0.0
    | _ => false
    }
  },
  rs => moveLeft(),
  ~salient=Salience(20.0),
)
```

**Benefits**:
1. **Action handler becomes declarative**: Just checks facts and executes simple actions
2. **Rules encode the logic**: Predicates assert/retract facts based on game state
3. **Easier to test**: Can verify facts are asserted correctly
4. **More composable**: Combine facts to make decisions (e.g., `attackFromLeft && safeToMoveRight => moveRight`)

### Graded Facts for Continuous Values

Facts don't have to be binary (true/false). You can use grades to represent **continuous values** or **ratios**. This is especially useful for space availability, distances, or any measurable quantity.

**Example**: Space availability as a ratio

```rescript
// Calculate grade from state (e.g., 16px space / 32px pokemon = 0.5 grade)
ai->RuleSystem.addRuleExecutingAction(
  rs => true,
  rs => {
    let grade = calculateSpaceGrade(rs.state)
    rs->RuleSystem.assertFact(Fact("moreSpaceOnLeft"), ~grade=Grade(grade))
  },
  ~salient=Salience(0.0),
)
```

**Benefits of graded space facts**:
- **Better decision-making**: If `moreSpaceOnRight` is 0.1 (very little space), avoid moving right even if technically safe
- **Prioritization**: When both sides are safe, choose the side with more space (higher grade)
- **Threshold-based logic**: Only move if space grade > 0.3, for example

**Example usage in decisions**:

```rescript
switch (
  RuleSystem.gradeForFact(rs, Fact("attackFromLeft")),
  RuleSystem.gradeForFact(rs, Fact("moreSpaceOnRight")),
) {
| (Grade(attackL), Grade(spaceR)) when attackL > 0.0 && spaceR > 0.3 => {
    // Attack from left, enough space on right -> move right
    moveRight()
  }
| _ => ()
}
```

### Dynamically Computed Grades: `addRuleExecutingAction` vs `addRuleAssertingFact`

When you need to compute a fact's grade dynamically from the rule system state, you **must use `addRuleExecutingAction`** instead of `addRuleAssertingFact`.

**Why?** `addRuleAssertingFact` takes a fixed `~grade` parameter that's set when the rule is created, not computed from state:

```rescript
// ❌ This doesn't work for dynamic grades
rs->RuleSystem.addRuleAssertingFact(
  rs => rs.state.health < 30,
  Fact("lowHealth"),
  ~grade=Grade(???),  // Can't compute from rs.state here!
)
```

**The Solution**: Use `addRuleExecutingAction` to compute the grade dynamically and call `assertFact`:

```rescript
// ✅ Correct: Compute grade dynamically from state
rs->RuleSystem.addRuleExecutingAction(
  rs => true,  // Always execute (or add predicate if needed)
  rs => {
    // Access state and compute grade
    let state = rs.state
    let grade = calculateProximityGrade(state.enemyPos, state.attackPos)
    rs->RuleSystem.assertFact(Fact("attackNearby"), ~grade=Grade(grade))
  },
  ~salient=Salience(0.0),
)
```

**When to Use Each**:

| Use Case | Method | Example |
|----------|--------|---------|
| **Fixed grade** (binary or constant) | `addRuleAssertingFact` | `~grade=Grade(1.0)` for boolean facts |
| **Grade computed from state** | `addRuleExecutingAction` + `assertFact` | Distance calculations, ratios, proximity |
| **Grade depends on calculations** | `addRuleExecutingAction` + `assertFact` | Space availability, threat levels |

**Example**: Proximity-based threat detection

```rescript
// Compute threat grade based on distance calculations
ai->RuleSystem.addRuleExecutingAction(
  rs => true,
  rs => {
    // Calculate grade from state (e.g., distance, proximity, ratios)
    let grade = calculateThreatGrade(rs.state)
    rs->RuleSystem.assertFact(Fact("threatNearby"), ~grade=Grade(grade))
  },
  ~salient=Salience(0.0),
)
```

**Key Points**:
- `addRuleAssertingFact` is for **fixed grades** (binary or constant values)
- `addRuleExecutingAction` + `assertFact` is for **dynamic grades** computed from state
- Always assert the fact (even with grade 0.0) so retract rules can clear it if needed
- Use appropriate salience to ensure facts are computed in the correct order

## Advanced Features

### Working with Multiple Facts

The system provides helper methods to work with multiple facts at once:

```rescript
open Kaplay

let k = Context.kaplay()
let ai = RuleSystem.make(k)

ai->RuleSystem.assertFact(Fact("fact1"), ~grade=Grade(0.3))
ai->RuleSystem.assertFact(Fact("fact2"), ~grade=Grade(0.7))
ai->RuleSystem.assertFact(Fact("fact3"), ~grade=Grade(0.5))

// Get the minimum grade among facts
let minGrade = ai->RuleSystem.minimumGradeForFacts(Fact("fact1"), Fact("fact2"), Fact("fact3"))
switch minGrade {
| Grade(g) => Console.log(g) // 0.3
}

// Get the maximum grade among facts
let maxGrade = ai->RuleSystem.maximumGradeForFacts(Fact("fact1"), Fact("fact2"), Fact("fact3"))
switch maxGrade {
| Grade(g) => Console.log(g) // 0.7
}
```

### Custom Rules

For advanced scenarios, you can create custom rules by extending the `Rule` class:

```javascript
const ai = new k.RuleSystem();

class CustomRule extends k.Rule {
    constructor(predicate, salience) {
        super(predicate, salience);
    }

    execute(system) {
        // Your custom logic here
        console.log("Custom rule executed!");
    }
}

const customRule = new CustomRule(
    (system) => system.state.customCondition === true,
    0
);

ai.addRule(customRule);
```

### State Management

The `state` property is a free-form object where you can store any game state:

```rescript
open Kaplay

let k = Context.kaplay()

type gameState = {
  mutable playerHealth: int,
  mutable enemyCount: int,
  mutable distanceToGoal: float,
  mutable hasKey: bool,
  mutable shouldFlee: bool,
}

let ai = RuleSystem.make(k)

// Store game state
ai.state = {
  playerHealth: 100,
  enemyCount: 5,
  distanceToGoal: 200.0,
  hasKey: true,
  shouldFlee: false,
}

// Use state in predicates
ai->RuleSystem.addRuleExecutingAction(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.playerHealth < 50 && state.enemyCount > 3
  },
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    Console.log("Dangerous situation!")
    state.shouldFlee = true
  },
)
```

## Practical Example: Enemy AI

Here's an example of an enemy AI using the RuleSystem:

```rescript
// Rule 1: If health is critically low, retreat
enemyAI->RuleSystem.addRuleAssertingFact(
  rs => rs.state.health < 20,
  Fact("shouldRetreat"),
  ~grade=Grade(1.0),
  ~salient=Salience(-10.0), // High priority
)

// Rule 2: If player is very close, assert "playerTooClose"
enemyAI->RuleSystem.addRuleAssertingFact(
  rs => rs.state.distanceToPlayer < 30.0,
  Fact("playerTooClose"),
  ~grade=Grade(1.0),
)

// Rule 3: If we should retreat, move away
enemyAI->RuleSystem.addRuleExecutingAction(
  rs => {
    switch rs->RuleSystem.gradeForFact(Fact("shouldRetreat")) {
    | Grade(g) => g > 0.5
    | _ => false
    }
  },
  rs => {
    rs.state.movingAway = true
  },
)

// Rule 4: If player is too close and we have ammo, attack
enemyAI->RuleSystem.addRuleExecutingAction(
  rs => {
    let state = rs.state
    switch rs->RuleSystem.gradeForFact(Fact("playerTooClose")) {
    | Grade(g) => g > 0.5 && state.ammo > 0
    | _ => false
    }
  },
  rs => {
    rs.state.ammo = rs.state.ammo - 1
  },
  ~salient=Salience(5.0),
)
```

## API Reference

### RuleSystem Class

#### Constructor

```typescript
new RuleSystem()
```

Creates a new rule system instance.

#### Properties

- **`agenda: Rule[]`** - Array of all rules in the system
- **`state: any`** - Free-form object for storing game state
- **`facts: Map<string, number>`** - Map of fact names to their grades

#### Methods

##### `addRuleExecutingAction(predicate, action, salience?)`

Adds a rule that executes an action when the predicate is true.

- **`predicate: (system: RuleSystem) => boolean`** - Function that returns true when the rule should execute
- **`action: (system: RuleSystem) => void`** - Function to execute when predicate is true
- **`salience: number`** - Priority level (default: 0). Lower values execute first

##### `addRuleAssertingFact(predicate, fact, grade?, salience?)`

Adds a rule that asserts a fact when the predicate is true.

- **`predicate: (system: RuleSystem) => boolean`** - Function that returns true when the rule should execute
- **`fact: string`** - Name of the fact to assert
- **`grade: number`** - Grade to add to the fact (default: 1)
- **`salience: number`** - Priority level (default: 0)

##### `addRuleRetractingFact(predicate, fact, grade?, salience?)`

Adds a rule that retracts (reduces the grade of) a fact when the predicate is true.

- **`predicate: (system: RuleSystem) => boolean`** - Function that returns true when the rule should execute
- **`fact: string`** - Name of the fact to retract
- **`grade: number`** - Grade to subtract from the fact (default: 1)
- **`salience: number`** - Priority level (default: 0)

##### `addRule(rule)`

Adds a custom rule to the system.

- **`rule: Rule`** - A custom rule instance

##### `removeAllRules()`

Removes all rules from the system.

##### `execute()`

Evaluates all rules and executes those whose predicates are true. Rules are executed in order of salience (ascending).

##### `assertFact(fact, grade?)`

Asserts a fact with a given grade. The grade is clamped to a maximum of 1.0.

- **`fact: string`** - Name of the fact
- **`grade: number`** - Grade to add (default: 1). If the fact already exists, grades are added together (capped at 1.0)

##### `retractFact(fact, grade?)`

Retracts a fact by reducing its grade. The grade is clamped to a minimum of 0.0.

- **`fact: string`** - Name of the fact
- **`grade: number`** - Grade to subtract (default: 1). If the fact doesn't exist, it's treated as having grade 0

##### `gradeForFact(fact)`

Returns the current grade of a fact.

- **`fact: string`** - Name of the fact
- **Returns:** `number` - The grade (0 if fact doesn't exist)

**Note**: You don't need to assert facts with grade 0.0. If a fact doesn't exist in the facts map, `gradeForFact` will return 0.0 automatically. You can also check if a fact key is missing in the map using `rs.facts->Map.has(factName)` if you need to distinguish between "not asserted" and "explicitly set to 0.0".

##### `minimumGradeForFacts(...facts)`

Returns the minimum grade among the specified facts.

- **`...facts: string[]`** - Fact names to check
- **Returns:** `number` - The minimum grade

##### `maximumGradeForFacts(...facts)`

Returns the maximum grade among the specified facts.

- **`...facts: string[]`** - Fact names to check
- **Returns:** `number` - The maximum grade

##### `reset()`

Clears all facts from the system. Rules and state are preserved.

### Rule Class

The `Rule` class is exported and can be extended for custom rule implementations.

#### Constructor

```typescript
new Rule(predicate: (system: RuleSystem) => boolean, salience: number)
```

#### Properties

- **`predicate: (system: RuleSystem) => boolean`** - The condition function
- **`salience: number`** - Priority level

#### Methods

##### `evaluate(system)`

Evaluates the rule's predicate.

- **`system: RuleSystem`** - The rule system instance
- **Returns:** `boolean` - Result of the predicate

##### `execute(system)`

Executes the rule's action. Override this in custom rules.

- **`system: RuleSystem`** - The rule system instance

## Best Practices

1. **Use meaningful fact names**: Choose descriptive names like `"playerNearby"` instead of `"p1"`

2. **Use assert/retract pairs for state facts**: When a fact represents current state (like `"playerFar"` or `"lowHealth"`), always pair `addRuleAssertingFact` with a corresponding `addRuleRetractingFact` that has the opposite condition. This ensures facts accurately reflect reality. See [Understanding Assert/Retract Pairs](#understanding-assertretract-pairs) for details.

3. **Organize salience values**: Use consistent salience ranges (e.g., -100 to 100) to make priority management easier

4. **Keep predicates simple**: Complex logic in predicates can make debugging difficult. Consider breaking complex conditions into multiple facts

5. **Update state before executing**: Always update `state` and facts before calling `execute()` to ensure rules evaluate current conditions

6. **Reset when needed**: Use `reset()` to clear facts when transitioning between game states or scenes

7. **Combine with game loops**: Call `execute()` in your `onUpdate()` or `onFixedUpdate()` handlers to keep AI responsive

## Common Patterns

### Pattern: State Machine

Use facts to represent states and rules to handle transitions:

```rescript
// Define states as facts
stateMachine->RuleSystem.assertFact(Fact("idle"), ~grade=Grade(1.0))

// Transition: idle -> patrolling when player is far
stateMachine->RuleSystem.addRuleRetractingFact(
  rs => {
    let state = rs.state
    switch rs->RuleSystem.gradeForFact(Fact("idle")) {
    | Grade(g) => g > 0.0 && state.distanceToPlayer > 100.0
    | _ => false
    }
  },
  Fact("idle"),
  ~grade=Grade(1.0),
)

stateMachine->RuleSystem.addRuleAssertingFact(
  rs => {
    let state = rs.state
    switch rs->RuleSystem.gradeForFact(Fact("idle")) {
    | Grade(g) => g > 0.0 && state.distanceToPlayer > 100.0
    | _ => false
    }
  },
  Fact("patrolling"),
  ~grade=Grade(1.0),
  ~salient=Salience(1.0),
)
```

### Pattern: Fuzzy Logic

Use fact grades to represent fuzzy concepts:

```rescript
// "Very close" has high grade when distance is small
fuzzyAI->RuleSystem.addRuleAssertingFact(
  rs => rs.state.distance < 20.0,
  Fact("veryClose"),
  ~grade=Grade(1.0),
)

fuzzyAI->RuleSystem.addRuleAssertingFact(
  rs => {
    let state = rs.state
    state.distance < 50.0 && state.distance >= 20.0
  },
  Fact("veryClose"),
  ~grade=Grade(0.5),
  ~salient=Salience(1.0),
)

// Use the fuzzy fact in decisions
fuzzyAI->RuleSystem.addRuleExecutingAction(
  rs => {
    switch rs->RuleSystem.gradeForFact(Fact("veryClose")) {
    | Grade(g) => g > 0.7
    | _ => false
    }
  },
  rs => Console.log("Player is very close!"),
)
```

### Pattern: Event-Driven Rules

Combine with KAPLAY events to create reactive AI:

```rescript
// When player takes damage, assert "underAttack"
k->Context.onCollide("enemy", "player", () => {
  reactiveAI->RuleSystem.assertFact(Fact("underAttack"), ~grade=Grade(1.0))
})

// Rule responds to the event
reactiveAI->RuleSystem.addRuleExecutingAction(
  rs => {
    switch rs->RuleSystem.gradeForFact(Fact("underAttack")) {
    | Grade(g) => g > 0.0
    | _ => false
    }
  },
  rs => {
    rs.state.defending = true
    rs->RuleSystem.retractFact(Fact("underAttack"), ~grade=Grade(1.0))
  },
)
```

## Tips and Tricks

- **Debugging**: Log fact grades and state values to understand rule execution flow
- **Performance**: Keep the number of rules reasonable. For complex systems, consider using multiple RuleSystem instances
- **Testing**: Test rules in isolation by manually setting facts and state before calling `execute()`
- **Modularity**: Create separate RuleSystem instances for different AI agents or systems

## See Also

- `DecisionTree` - For tree-based decision making
- `StateMachine` - For finite state machine patterns
