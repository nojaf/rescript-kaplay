# RuleSystem - Rule-Based AI System for KAPLAY

## Overview

The `RuleSystem` is a powerful rule-based AI system that allows you to create intelligent behaviors using a pattern of "if-then" rules. It's perfect for implementing decision-making logic, state management, and AI behaviors in your KAPLAY games.

The system works by evaluating rules against a set of facts. When a rule's condition (predicate) is true, it executes its action. Facts are stored with a grade (0 to 1), allowing you to represent confidence levels or fuzzy logic.

## Getting Started

To use `RuleSystem`, you first need to create an instance. It's available through the KAPLAY context:

```rescript
open Kaplay

let k = Context.kaplay()

// Create a new rule system
let ai = RuleSystem.make(k)
```

## Core Concepts

### Facts

Facts are pieces of information stored in the system. Each fact has a name (string) and a grade (number between 0 and 1). The grade represents the strength or confidence of the fact.

- **Grade 0**: The fact is not true (or has no confidence)
- **Grade 1**: The fact is fully true (or has maximum confidence)
- **Grades between 0 and 1**: Partial truth or confidence levels

### Rules

Rules define the behavior of your AI system. Each rule has:
- **Predicate**: A condition that evaluates to true or false
- **Action**: What happens when the predicate is true
- **Salience**: Priority level (lower numbers execute first)

### Execution Flow

When you call `execute()`, the system:
1. Sorts all rules by salience (ascending order)
2. Evaluates each rule's predicate
3. Executes the action for rules where the predicate is true

## Basic Usage

### Creating a Simple Rule

Here's a basic example that demonstrates the core workflow:

```rescript
open Kaplay

let k = Context.kaplay()

type gameState = {mutable health: int}

let ai = RuleSystem.make(k)

// Set initial state
ai.state = {health: 50}

// Add a rule that executes an action when a condition is met
ai->RuleSystem.addRuleExecutingAction(
  // Predicate: when player health is low
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.health < 30
  },
  // Action: heal the player
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.health = state.health + 20
    Console.log("Healing player!")
  },
  ~salient=Salience(0.0), // Salience (priority)
)

// Execute the rules
ai->RuleSystem.execute() // Nothing happens (health is 50, not < 30)

ai.state.health = 25
ai->RuleSystem.execute() // "Healing player!" - health is now 45
```

### Working with Facts

Facts allow you to build more complex decision-making systems:

```rescript
open Kaplay

let k = Context.kaplay()
let ai = RuleSystem.make(k)

// Assert some facts
ai->RuleSystem.assertFact(Fact("playerNearby"), ~grade=Grade(0.8))  // 80% confidence player is nearby
ai->RuleSystem.assertFact(Fact("lowHealth"), ~grade=Grade(1.0))     // 100% confidence health is low
ai->RuleSystem.assertFact(Fact("hasAmmo"), ~grade=Grade(0.5))        // 50% confidence we have ammo

// Check fact grades
switch ai->RuleSystem.gradeForFact(Fact("playerNearby")) {
| Grade(g) => Console.log(g) // 0.8
}
switch ai->RuleSystem.gradeForFact(Fact("lowHealth")) {
| Grade(g) => Console.log(g) // 1.0
}
switch ai->RuleSystem.gradeForFact(Fact("hasAmmo")) {
| Grade(g) => Console.log(g) // 0.5
}
```

### Rules with Facts

You can create rules that check facts and assert or retract other facts:

```rescript
open Kaplay

let k = Context.kaplay()
let ai = RuleSystem.make(k)

// Rule: If player is nearby and we have low health, assert "shouldRetreat"
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<'state>) => {
    switch (rs->RuleSystem.gradeForFact(Fact("playerNearby")), rs->RuleSystem.gradeForFact(Fact("lowHealth"))) {
    | (Grade(pn), Grade(lh)) => pn > 0.7 && lh > 0.8
    | _ => false
    }
  },
  Fact("shouldRetreat"),  // Fact to assert
  ~grade=Grade(1.0),      // Grade to assert with
)

// Set up initial facts
ai->RuleSystem.assertFact(Fact("playerNearby"), ~grade=Grade(0.9))
ai->RuleSystem.assertFact(Fact("lowHealth"), ~grade=Grade(0.9))

// Execute rules
ai->RuleSystem.execute()

// Check if the new fact was asserted
switch ai->RuleSystem.gradeForFact(Fact("shouldRetreat")) {
| Grade(g) => Console.log(g) // 1.0
}
```

### Retracting Facts

You can also create rules that retract (reduce the grade of) facts:

```rescript
open Kaplay

let k = Context.kaplay()

type gameState = {mutable distanceToPlayer: float}

let ai = RuleSystem.make(k)

// Rule: If player moves away, retract "playerNearby"
ai->RuleSystem.addRuleRetractingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.distanceToPlayer > 100.0
  },
  Fact("playerNearby"),  // Fact to retract
  ~grade=Grade(0.5),     // Grade to retract by
)

ai.state = {distanceToPlayer: 0.0}
ai->RuleSystem.assertFact(Fact("playerNearby"), ~grade=Grade(1.0))

ai.state.distanceToPlayer = 150.0
ai->RuleSystem.execute()

switch ai->RuleSystem.gradeForFact(Fact("playerNearby")) {
| Grade(g) => Console.log(g) // 0.5 (reduced by 0.5)
}
```

> **Important**: See the section on [Understanding Assert/Retract Pairs](#understanding-assertretract-pairs) below for guidance on when you need to pair assert and retract rules together.

### Understanding Assert/Retract Pairs

An important design consideration when using `addRuleAssertingFact` and `addRuleRetractingFact` is whether you need them in pairs. The answer depends on your use case:

**Key Point**: Facts persist until explicitly retracted or reset. When a rule's predicate becomes false, the fact it asserted remains at its current grade unless another rule retracts it.

#### When You Need Pairs (Mutually Exclusive States)

For facts that represent **current state** or **mutually exclusive conditions**, you should use pairs to ensure facts accurately reflect reality:

```rescript
open Kaplay

let k = Context.kaplay()

type gameState = {mutable playerDistance: float}

let ai = RuleSystem.make(k)

// Assert "playerFar" when distance > 10
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.playerDistance > 10.0
  },
  Fact("playerFar"),
  ~grade=Grade(1.0),
)

// Retract "playerFar" when distance <= 10 (the opposite condition)
ai->RuleSystem.addRuleRetractingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.playerDistance <= 10.0
  },
  Fact("playerFar"),
  ~grade=Grade(1.0),
)

// Now "playerFar" accurately reflects current state
ai.state = {playerDistance: 15.0}
ai->RuleSystem.execute()
switch ai->RuleSystem.gradeForFact(Fact("playerFar")) {
| Grade(g) => Console.log(g) // 1.0
}

ai.state.playerDistance = 5.0
ai->RuleSystem.execute()
switch ai->RuleSystem.gradeForFact(Fact("playerFar")) {
| Grade(g) => Console.log(g) // 0.0
}
```

**Why pairs matter here**: Without the retract rule, once `playerFar` is asserted, it would remain true even when the player gets close, leading to incorrect behavior.

#### When You Don't Need Pairs (Accumulating Evidence)

For facts that represent **accumulating evidence**, **events**, or **persistent knowledge**, you typically don't need retract rules:

```rescript
open Kaplay

let k = Context.kaplay()

type gameState = {mutable hasLineOfSight: bool}

let ai = RuleSystem.make(k)

// Assert "playerSeen" when player is visible
// This fact persists - once seen, always "seen" (until reset)
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.hasLineOfSight
  },
  Fact("playerSeen"),
  ~grade=Grade(1.0),
)

// No retract rule needed - "playerSeen" is a persistent fact
// It represents historical knowledge, not current state
```

**When to use this pattern**: 
- Historical events ("enemyAttacked", "keyCollected")
- Accumulated evidence ("suspiciousActivity")
- Persistent states that should remain until explicitly cleared

#### The Twofold Pattern

For facts representing **current conditions**, use the twofold pattern where each assertion has a corresponding retraction with the opposite condition:

```rescript
open Kaplay

let k = Context.kaplay()

type gameState = {mutable health: int}

let ai = RuleSystem.make(k)

// Pattern: Assert when condition is true
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.health < 30
  },
  Fact("lowHealth"),
  ~grade=Grade(1.0),
)

// Pattern: Retract when condition is false (opposite)
ai->RuleSystem.addRuleRetractingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.health >= 30
  },
  Fact("lowHealth"),
  ~grade=Grade(1.0),
)

// This ensures "lowHealth" always reflects current reality
```

**Best Practice**: When a fact represents a **current state** (like "playerFar", "lowHealth", "inCombat"), use the twofold pattern. When it represents **historical knowledge** or **accumulated evidence**, you typically don't need pairs.

#### Handling Multiple Sources

Sometimes multiple rules can assert the same fact. In these cases, you might want selective retraction:

```rescript
open Kaplay

let k = Context.kaplay()

type gameState = {mutable health: int, mutable enemyCount: int}

let ai = RuleSystem.make(k)

// Source 1: Assert "danger" when health is low
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.health < 20
  },
  Fact("danger"),
  ~grade=Grade(0.5),  // Partial grade
)

// Source 2: Assert "danger" when enemies nearby
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.enemyCount > 3
  },
  Fact("danger"),
  ~grade=Grade(0.5),  // Partial grade
)

// Retract only when BOTH conditions are false
ai->RuleSystem.addRuleRetractingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.health >= 20 && state.enemyCount <= 3
  },
  Fact("danger"),
  ~grade=Grade(1.0),  // Full retraction
)

// Now "danger" can be 0.0, 0.5, or 1.0 depending on conditions
```

#### Common Pitfall: Forgetting Retract Rules

A common mistake is asserting facts without corresponding retracts for state-based facts:

```rescript
// ❌ PROBLEMATIC: Fact persists even when condition becomes false
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.playerDistance > 10.0
  },
  Fact("playerFar"),
  ~grade=Grade(1.0),
)
// Missing: retract rule for when distance <= 10

// ✅ CORRECT: Twofold pattern ensures accuracy
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.playerDistance > 10.0
  },
  Fact("playerFar"),
  ~grade=Grade(1.0),
)
ai->RuleSystem.addRuleRetractingFact(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.playerDistance <= 10.0
  },
  Fact("playerFar"),
  ~grade=Grade(1.0),
)
```

#### Summary: When to Use Pairs

| Use Case | Need Pair? | Example |
|----------|------------|---------|
| Current state facts | ✅ Yes | "playerFar", "lowHealth", "inCombat" |
| Historical events | ❌ No | "playerSeen", "keyCollected" |
| Accumulated evidence | ❌ No | "suspiciousActivity" |
| Temporary conditions | ✅ Yes | "underAttack", "nearGoal" |
| Persistent knowledge | ❌ No | "hasVisitedArea", "knowsSecret" |

**Rule of thumb**: If the fact should **automatically become false** when conditions change, use a pair. If the fact represents **something that happened** or **knowledge gained**, you typically don't need a retract rule.

## Salience and Rule Execution Order

Salience controls the order in which rules execute. This is fundamental to how the rule system works, not just an advanced feature. Understanding salience is crucial for building systems where facts depend on other facts.

### How Salience Works

Rules are sorted by salience in **ascending order** (lower values execute first). When `execute()` is called:

1. All rules are sorted by salience (ascending)
2. Each rule's predicate is evaluated
3. Rules with true predicates execute their actions

**Key Point**: Facts asserted by rules at lower salience values are **immediately available** to rules at higher salience values in the same execution cycle.

### Basic Priority Control

You can use salience to control execution order:

```rescript
open Kaplay

let k = Context.kaplay()

type gameState = {mutable health: int, mutable alive: bool}

let ai = RuleSystem.make(k)

// High priority rule (executes first)
ai->RuleSystem.addRuleExecutingAction(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.health <= 0
  },
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    Console.log("Player died!")
    state.alive = false
  },
  ~salient=Salience(-10.0), // Low salience = high priority
)

// Lower priority rule
ai->RuleSystem.addRuleExecutingAction(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.health < 50
  },
  (rs: RuleSystem.t<gameState>) => {
    Console.log("Health is low")
  },
  ~salient=Salience(10.0), // Higher salience = lower priority
)

ai.state = {health: 0, alive: true}
ai->RuleSystem.execute() // "Player died!" executes first, then "Health is low"
```

### Fact Dependencies and Salience

The most powerful use of salience is creating **fact dependencies**: rules that compute facts from other facts. Facts asserted at lower salience are available to rules at higher salience.

```rescript
open Kaplay

let k = Context.kaplay()

module Salience = {
  // Tier 1: Base facts computed from game state (no dependencies)
  let baseFacts = Salience(0.0)
  
  // Tier 2: Derived facts that depend on base facts
  let derivedFacts = Salience(10.0)
  
  // Tier 3: Decision/action rules that depend on all facts
  let decisions = Salience(20.0)
}

type enemyState = {
  mutable enemyX: float,
  mutable attackX: float,
  mutable screenWidth: float,
}

let ai = RuleSystem.make(k)

// Tier 1: Base facts (salience 0.0) - computed from game state
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<enemyState>) => {
    let state = rs.state
    state.attackX < state.enemyX
  },
  Fact("attackFromLeft"),
  ~grade=Grade(1.0),
  ~salient=Salience.baseFacts,
)

// Tier 2: Derived fact (salience 10.0) - can read base facts
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<enemyState>) => {
    // ✅ This CAN read attackFromLeft because it was asserted at salience 0.0
    switch (
      RuleSystem.gradeForFact(rs, Fact("attackFromLeft")),
      RuleSystem.gradeForFact(rs, Fact("moreSpaceOnRight")),
    ) {
    | (Grade(attackL), Grade(spaceR)) => 
      attackL > 0.0 && spaceR > 0.3  // Attack from left AND enough space on right
    | _ => false
    }
  },
  Fact("safeToMoveRight"),
  ~grade=Grade(1.0),
  ~salient=Salience.derivedFacts, // Executes AFTER base facts
)
```

**Important**: Facts are stored in a mutable map that's updated immediately when rules execute. This means:
- Rules at salience 0.0 can assert facts
- Rules at salience 10.0 can read those facts in the same `execute()` call
- Rules at salience 20.0 can read both base and derived facts

### Recommended Salience Strategy

Use a tiered approach with clear separation:

```rescript
module Salience = {
  let baseFacts = Salience(0.0)      // Facts from game state
  let derivedFacts = Salience(10.0)   // Facts from other facts
  let decisions = Salience(20.0)      // Actions based on facts
}
```

This makes dependencies explicit and ensures facts are computed in the correct order.

## Fact Decomposition

Complex facts that encode too much information can lead to complex branching logic in action handlers. Breaking them down into smaller, focused facts makes the system more declarative and easier to reason about.

### The Problem: Too Broad Facts

Consider a fact like `attackIncoming` that only tells you "there's an attack" but doesn't encode:
- **Where** the attack is relative to the enemy
- **Which directions** are safe to move
- **How much space** is available

This forces action handlers to compute these at runtime, leading to complex if/else chains:

```rescript
// ❌ PROBLEMATIC: Too much logic in action handler
switch RuleSystem.gradeForFact(rs, Fact("attackIncoming")) {
| Grade(g) when g > 0.0 => {
    // Complex runtime computation
    let (attackOnLeft, attackOnRight) = verifyAttacks(rs)
    if attackOnLeft {
      moveRight()
    } else if attackOnRight {
      moveLeft()
    } else {
      // More complex space calculations...
    }
  }
| _ => ()
}
```

### The Solution: Decompose into Focused Facts

Break down the broad fact into smaller, focused facts:

**Positional Facts** (describe where things are):
- `attackFromLeft` - Attack exists to the left
- `attackFromRight` - Attack exists to the right
- `attackAligned` - Attack is aligned (same X position)

**Space Facts** (describe available space):
- `moreSpaceOnLeft` - Space available on left (graded 0.0-1.0)
- `moreSpaceOnRight` - Space available on right (graded 0.0-1.0)

**Derived Facts** (computed from other facts):
- `safeToMoveLeft` - Safe to move left (derived from attack and space facts)
- `safeToMoveRight` - Safe to move right (derived from attack and space facts)

### Example: Refactoring with Fact Decomposition

```rescript
open Kaplay

let k = Context.kaplay()

type enemyState = {
  mutable enemyX: float,
  mutable enemyWidth: float,
  mutable attackX: float,
  mutable screenWidth: float,
}

let ai = RuleSystem.make(k)

// Base facts: Positional information (salience 0.0)
ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<enemyState>) => {
    let state = rs.state
    state.attackX < state.enemyX
  },
  Fact("attackFromLeft"),
  ~grade=Grade(1.0),
  ~salient=Salience(0.0),
)

ai->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<enemyState>) => {
    let state = rs.state
    state.attackX > state.enemyX
  },
  Fact("attackFromRight"),
  ~grade=Grade(1.0),
  ~salient=Salience(0.0),
)

// Base facts: Space availability (graded for continuous values)
ai->RuleSystem.addRuleExecutingAction(
  rs => true,
  rs => {
    let state = rs.state
    let availableSpaceLeft = state.enemyX
    let spaceGrade = Stdlib_Math.min(1.0, availableSpaceLeft /. state.enemyWidth)
    rs->RuleSystem.assertFact(Fact("moreSpaceOnLeft"), ~grade=Grade(spaceGrade))
  },
  ~salient=Salience(0.0),
)

// Derived facts: Safety (salience 10.0 - depends on base facts)
ai->RuleSystem.addRuleAssertingFact(
  rs => {
    // ✅ Can read base facts because they were asserted at salience 0.0
    switch (
      RuleSystem.gradeForFact(rs, Fact("attackFromRight")),
      RuleSystem.gradeForFact(rs, Fact("moreSpaceOnLeft")),
    ) {
    | (Grade(attackR), Grade(spaceL)) => 
      attackR == 0.0 && spaceL > 0.3  // No attack from right AND enough space
    | _ => false
    }
  },
  Fact("safeToMoveLeft"),
  ~grade=Grade(1.0),
  ~salient=Salience(10.0), // Executes AFTER base facts
)

// Action handler becomes declarative (salience 20.0)
ai->RuleSystem.addRuleExecutingAction(
  rs => {
    switch RuleSystem.gradeForFact(rs, Fact("safeToMoveLeft")) {
    | Grade(g) => g > 0.0
    | _ => false
    }
  },
  rs => {
    // Simple, declarative action
    moveLeft()
  },
  ~salient=Salience(20.0),
)
```

**Benefits**:
1. **Action handler becomes declarative**: Just checks facts and executes simple actions
2. **Rules encode the logic**: Predicates assert/retract facts based on game state
3. **Easier to test**: Can verify facts are asserted correctly
4. **More composable**: Combine facts to make decisions (e.g., `attackFromLeft && safeToMoveRight => moveRight`)

### Graded Facts for Continuous Values

Facts don't have to be binary (true/false). You can use grades to represent **continuous values** or **ratios**. This is especially useful for space availability, distances, or any measurable quantity.

**Example**: Space availability as a ratio

```rescript
// Calculate space grade: availableSpace / requiredSpace
let calculateSpaceGrade = (availableSpace: float, requiredSpace: float): float => {
  Stdlib_Math.min(1.0, availableSpace /. requiredSpace)
}

// If there's 16px space and pokemon is 32px wide:
// grade = min(1.0, 16 / 32) = 0.5

ai->RuleSystem.addRuleExecutingAction(
  rs => true,
  rs => {
    let state = rs.state
    let availableSpaceLeft = state.enemyX
    let pokemonWidth = state.enemyWidth
    let grade = calculateSpaceGrade(availableSpaceLeft, pokemonWidth)
    rs->RuleSystem.assertFact(Fact("moreSpaceOnLeft"), ~grade=Grade(grade))
  },
  ~salient=Salience(0.0),
)
```

**Benefits of graded space facts**:
- **Better decision-making**: If `moreSpaceOnRight` is 0.1 (very little space), avoid moving right even if technically safe
- **Prioritization**: When both sides are safe, choose the side with more space (higher grade)
- **Threshold-based logic**: Only move if space grade > 0.3, for example

**Example usage in decisions**:

```rescript
switch (
  RuleSystem.gradeForFact(rs, Fact("attackFromLeft")),
  RuleSystem.gradeForFact(rs, Fact("moreSpaceOnRight")),
) {
| (Grade(attackL), Grade(spaceR)) when attackL > 0.0 && attackR == 0.0 && spaceR > 0.3 => {
    // Attack from left, safe on right, enough space -> move right
    moveRight()
  }
| (Grade(attackL), Grade(spaceR)) when attackL > 0.0 && attackR > 0.0 => {
    // Attacks on both sides - choose side with more space
    if spaceL > spaceR && spaceL > 0.2 {
      moveLeft()
    } else if spaceR > spaceL && spaceR > 0.2 {
      moveRight()
    }
  }
| _ => ()
}
```

## Advanced Features

### Working with Multiple Facts

The system provides helper methods to work with multiple facts at once:

```rescript
open Kaplay

let k = Context.kaplay()
let ai = RuleSystem.make(k)

ai->RuleSystem.assertFact(Fact("fact1"), ~grade=Grade(0.3))
ai->RuleSystem.assertFact(Fact("fact2"), ~grade=Grade(0.7))
ai->RuleSystem.assertFact(Fact("fact3"), ~grade=Grade(0.5))

// Get the minimum grade among facts
let minGrade = ai->RuleSystem.minimumGradeForFacts(Fact("fact1"), Fact("fact2"), Fact("fact3"))
switch minGrade {
| Grade(g) => Console.log(g) // 0.3
}

// Get the maximum grade among facts
let maxGrade = ai->RuleSystem.maximumGradeForFacts(Fact("fact1"), Fact("fact2"), Fact("fact3"))
switch maxGrade {
| Grade(g) => Console.log(g) // 0.7
}
```

### Custom Rules

For advanced scenarios, you can create custom rules by extending the `Rule` class:

```javascript
const ai = new k.RuleSystem();

class CustomRule extends k.Rule {
    constructor(predicate, salience) {
        super(predicate, salience);
    }

    execute(system) {
        // Your custom logic here
        console.log("Custom rule executed!");
    }
}

const customRule = new CustomRule(
    (system) => system.state.customCondition === true,
    0
);

ai.addRule(customRule);
```

### State Management

The `state` property is a free-form object where you can store any game state:

```rescript
open Kaplay

let k = Context.kaplay()

type gameState = {
  mutable playerHealth: int,
  mutable enemyCount: int,
  mutable distanceToGoal: float,
  mutable hasKey: bool,
  mutable shouldFlee: bool,
}

let ai = RuleSystem.make(k)

// Store game state
ai.state = {
  playerHealth: 100,
  enemyCount: 5,
  distanceToGoal: 200.0,
  hasKey: true,
  shouldFlee: false,
}

// Use state in predicates
ai->RuleSystem.addRuleExecutingAction(
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    state.playerHealth < 50 && state.enemyCount > 3
  },
  (rs: RuleSystem.t<gameState>) => {
    let state = rs.state
    Console.log("Dangerous situation!")
    state.shouldFlee = true
  },
)
```

## Practical Example: Enemy AI

Here's a complete example of an enemy AI using the RuleSystem:

```rescript
open Kaplay

let k = Context.kaplay()

type enemyState = {
  mutable health: int,
  mutable distanceToPlayer: float,
  mutable ammo: int,
  mutable hasLineOfSight: bool,
  mutable movingAway: bool,
}

let enemyAI = RuleSystem.make(k)

// Initialize enemy state
enemyAI.state = {
  health: 100,
  distanceToPlayer: 50.0,
  ammo: 10,
  hasLineOfSight: true,
  movingAway: false,
}

// Rule 1: If health is critically low, retreat
enemyAI->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<enemyState>) => {
    let state = rs.state
    state.health < 20
  },
  Fact("shouldRetreat"),
  ~grade=Grade(1.0),
  ~salient=Salience(-10.0), // High priority
)

// Rule 2: If player is very close, assert "playerTooClose"
enemyAI->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<enemyState>) => {
    let state = rs.state
    state.distanceToPlayer < 30.0
  },
  Fact("playerTooClose"),
  ~grade=Grade(1.0),
)

// Rule 3: If we should retreat, move away
enemyAI->RuleSystem.addRuleExecutingAction(
  (rs: RuleSystem.t<enemyState>) => {
    switch rs->RuleSystem.gradeForFact(Fact("shouldRetreat")) {
    | Grade(g) => g > 0.5
    | _ => false
    }
  },
  (rs: RuleSystem.t<enemyState>) => {
    let state = rs.state
    Console.log("Enemy retreating!")
    state.movingAway = true
  },
)

// Rule 4: If player is too close and we have ammo, attack
enemyAI->RuleSystem.addRuleExecutingAction(
  (rs: RuleSystem.t<enemyState>) => {
    let state = rs.state
    switch rs->RuleSystem.gradeForFact(Fact("playerTooClose")) {
    | Grade(g) => g > 0.5 && state.ammo > 0 && state.hasLineOfSight
    | _ => false
    }
  },
  (rs: RuleSystem.t<enemyState>) => {
    let state = rs.state
    Console.log("Enemy attacking!")
    state.ammo = state.ammo - 1
  },
  ~salient=Salience(5.0),
)

// Rule 5: If out of ammo, retract "shouldRetreat" (can't fight anyway)
enemyAI->RuleSystem.addRuleRetractingFact(
  (rs: RuleSystem.t<enemyState>) => {
    let state = rs.state
    state.ammo == 0
  },
  Fact("shouldRetreat"),
  ~grade=Grade(0.3),
  ~salient=Salience(10.0),
)

// Game loop
k->Context.onUpdate(() => {
  // Update state based on game conditions
  enemyAI.state.distanceToPlayer = calculateDistance()
  enemyAI.state.hasLineOfSight = checkLineOfSight()
  
  // Execute AI rules
  enemyAI->RuleSystem.execute()
  
  // Act on the results
  if enemyAI.state.movingAway {
    moveEnemyAway()
    enemyAI.state.movingAway = false
  }
})
```

## API Reference

### RuleSystem Class

#### Constructor

```typescript
new RuleSystem()
```

Creates a new rule system instance.

#### Properties

- **`agenda: Rule[]`** - Array of all rules in the system
- **`state: any`** - Free-form object for storing game state
- **`facts: Map<string, number>`** - Map of fact names to their grades

#### Methods

##### `addRuleExecutingAction(predicate, action, salience?)`

Adds a rule that executes an action when the predicate is true.

- **`predicate: (system: RuleSystem) => boolean`** - Function that returns true when the rule should execute
- **`action: (system: RuleSystem) => void`** - Function to execute when predicate is true
- **`salience: number`** - Priority level (default: 0). Lower values execute first

##### `addRuleAssertingFact(predicate, fact, grade?, salience?)`

Adds a rule that asserts a fact when the predicate is true.

- **`predicate: (system: RuleSystem) => boolean`** - Function that returns true when the rule should execute
- **`fact: string`** - Name of the fact to assert
- **`grade: number`** - Grade to add to the fact (default: 1)
- **`salience: number`** - Priority level (default: 0)

##### `addRuleRetractingFact(predicate, fact, grade?, salience?)`

Adds a rule that retracts (reduces the grade of) a fact when the predicate is true.

- **`predicate: (system: RuleSystem) => boolean`** - Function that returns true when the rule should execute
- **`fact: string`** - Name of the fact to retract
- **`grade: number`** - Grade to subtract from the fact (default: 1)
- **`salience: number`** - Priority level (default: 0)

##### `addRule(rule)`

Adds a custom rule to the system.

- **`rule: Rule`** - A custom rule instance

##### `removeAllRules()`

Removes all rules from the system.

##### `execute()`

Evaluates all rules and executes those whose predicates are true. Rules are executed in order of salience (ascending).

##### `assertFact(fact, grade?)`

Asserts a fact with a given grade. The grade is clamped to a maximum of 1.0.

- **`fact: string`** - Name of the fact
- **`grade: number`** - Grade to add (default: 1). If the fact already exists, grades are added together (capped at 1.0)

##### `retractFact(fact, grade?)`

Retracts a fact by reducing its grade. The grade is clamped to a minimum of 0.0.

- **`fact: string`** - Name of the fact
- **`grade: number`** - Grade to subtract (default: 1). If the fact doesn't exist, it's treated as having grade 0

##### `gradeForFact(fact)`

Returns the current grade of a fact.

- **`fact: string`** - Name of the fact
- **Returns:** `number` - The grade (0 if fact doesn't exist)

##### `minimumGradeForFacts(...facts)`

Returns the minimum grade among the specified facts.

- **`...facts: string[]`** - Fact names to check
- **Returns:** `number` - The minimum grade

##### `maximumGradeForFacts(...facts)`

Returns the maximum grade among the specified facts.

- **`...facts: string[]`** - Fact names to check
- **Returns:** `number` - The maximum grade

##### `reset()`

Clears all facts from the system. Rules and state are preserved.

### Rule Class

The `Rule` class is exported and can be extended for custom rule implementations.

#### Constructor

```typescript
new Rule(predicate: (system: RuleSystem) => boolean, salience: number)
```

#### Properties

- **`predicate: (system: RuleSystem) => boolean`** - The condition function
- **`salience: number`** - Priority level

#### Methods

##### `evaluate(system)`

Evaluates the rule's predicate.

- **`system: RuleSystem`** - The rule system instance
- **Returns:** `boolean` - Result of the predicate

##### `execute(system)`

Executes the rule's action. Override this in custom rules.

- **`system: RuleSystem`** - The rule system instance

## Best Practices

1. **Use meaningful fact names**: Choose descriptive names like `"playerNearby"` instead of `"p1"`

2. **Use assert/retract pairs for state facts**: When a fact represents current state (like `"playerFar"` or `"lowHealth"`), always pair `addRuleAssertingFact` with a corresponding `addRuleRetractingFact` that has the opposite condition. This ensures facts accurately reflect reality. See [Understanding Assert/Retract Pairs](#understanding-assertretract-pairs) for details.

3. **Organize salience values**: Use consistent salience ranges (e.g., -100 to 100) to make priority management easier

4. **Keep predicates simple**: Complex logic in predicates can make debugging difficult. Consider breaking complex conditions into multiple facts

5. **Update state before executing**: Always update `state` and facts before calling `execute()` to ensure rules evaluate current conditions

6. **Reset when needed**: Use `reset()` to clear facts when transitioning between game states or scenes

7. **Combine with game loops**: Call `execute()` in your `onUpdate()` or `onFixedUpdate()` handlers to keep AI responsive

## Common Patterns

### Pattern: State Machine

Use facts to represent states and rules to handle transitions:

```rescript
open Kaplay

let k = Context.kaplay()

type stateMachineState = {mutable distanceToPlayer: float}

let stateMachine = RuleSystem.make(k)

// Define states as facts
stateMachine->RuleSystem.assertFact(Fact("idle"), ~grade=Grade(1.0))

// Transition: idle -> patrolling when player is far
stateMachine->RuleSystem.addRuleRetractingFact(
  (rs: RuleSystem.t<stateMachineState>) => {
    let state = rs.state
    switch rs->RuleSystem.gradeForFact(Fact("idle")) {
    | Grade(g) => g > 0.0 && state.distanceToPlayer > 100.0
    | _ => false
    }
  },
  Fact("idle"),
  ~grade=Grade(1.0),
)

stateMachine->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<stateMachineState>) => {
    let state = rs.state
    switch rs->RuleSystem.gradeForFact(Fact("idle")) {
    | Grade(g) => g > 0.0 && state.distanceToPlayer > 100.0
    | _ => false
    }
  },
  Fact("patrolling"),
  ~grade=Grade(1.0),
  ~salient=Salience(1.0),
)
```

### Pattern: Fuzzy Logic

Use fact grades to represent fuzzy concepts:

```rescript
open Kaplay

let k = Context.kaplay()

type fuzzyState = {mutable distance: float}

let fuzzyAI = RuleSystem.make(k)

// "Very close" has high grade when distance is small
fuzzyAI->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<fuzzyState>) => {
    let state = rs.state
    state.distance < 20.0
  },
  Fact("veryClose"),
  ~grade=Grade(1.0),
)

fuzzyAI->RuleSystem.addRuleAssertingFact(
  (rs: RuleSystem.t<fuzzyState>) => {
    let state = rs.state
    state.distance < 50.0 && state.distance >= 20.0
  },
  Fact("veryClose"),
  ~grade=Grade(0.5),
  ~salient=Salience(1.0),
)

// Use the fuzzy fact in decisions
fuzzyAI->RuleSystem.addRuleExecutingAction(
  (rs: RuleSystem.t<fuzzyState>) => {
    switch rs->RuleSystem.gradeForFact(Fact("veryClose")) {
    | Grade(g) => g > 0.7
    | _ => false
    }
  },
  (rs: RuleSystem.t<fuzzyState>) => {
    Console.log("Player is very close!")
  },
)
```

### Pattern: Event-Driven Rules

Combine with KAPLAY events to create reactive AI:

```rescript
open Kaplay

let k = Context.kaplay()

type reactiveState = {mutable defending: bool}

let reactiveAI = RuleSystem.make(k)

// When player takes damage, assert "underAttack"
k->Context.onCollide("enemy", "player", () => {
  reactiveAI->RuleSystem.assertFact(Fact("underAttack"), ~grade=Grade(1.0))
})

// Rule responds to the event
reactiveAI->RuleSystem.addRuleExecutingAction(
  (rs: RuleSystem.t<reactiveState>) => {
    switch rs->RuleSystem.gradeForFact(Fact("underAttack")) {
    | Grade(g) => g > 0.0
    | _ => false
    }
  },
  (rs: RuleSystem.t<reactiveState>) => {
    let state = rs.state
    Console.log("Enemy under attack, defending!")
    state.defending = true
    rs->RuleSystem.retractFact(Fact("underAttack"), ~grade=Grade(1.0))
  },
)
```

## Tips and Tricks

- **Debugging**: Log fact grades and state values to understand rule execution flow
- **Performance**: Keep the number of rules reasonable. For complex systems, consider using multiple RuleSystem instances
- **Testing**: Test rules in isolation by manually setting facts and state before calling `execute()`
- **Modularity**: Create separate RuleSystem instances for different AI agents or systems

## See Also

- `DecisionTree` - For tree-based decision making
- `StateMachine` - For finite state machine patterns
