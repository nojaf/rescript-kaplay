---
alwaysApply: false
---

# Skirmish Game Document

The premise of this game is to shake up the traditional Pokemon gameboy game formula and replace the turn-based gameplay with real-time gameplay.
The Player controls a pokemon and needs to battle their opponent.

## In-Game rules

- If a pokemon lost all hit points, the game is over.
- Pokemons can perform one or multiple moves (max 4) as in the original game. 
  - **Status**: Multiple moves per pokemon needs to be implemented.
  - **MVP Scope**: Minimum 2 moves per pokemon. May implement generic moves (like Tackle) that can be applied to each pokemon.
- Each move has:
  - A type, a water move is twice as effective against a fire pokemon
    - **Status**: TBD - Type effectiveness system not yet implemented.
  - A power points limit, you can not endlessly spawn each move
    - **Status**: TBD - PP system not yet implemented.
  - A cooldown system, you need to wait x amount of time before the (same of next?) move can be played again.
    - **Status**: TBD - Currently individual move cooldowns exist, but global cooldown behavior is undecided.
  - Its own mechanic, some moves are for close combat, others shoot a projectile.
    - **Move Categories** (TBD): Likely three categories:
      - Physical (close combat) attacks
      - Range attacks (projectiles)
      - Buffs (status effects)

## Reason for creating the game

This is a fun learning experiment, where we hope to gain:
- Some more insight into structuring game code. How to split code, find the right balance between being pragmatic and ensuring the core is still extensible.
- Learning how to create a `Rule System` for the enemy AI. Ideally, we create a single Rule System that is dynamic in nature and different pokemon (with different stats) lead to different experiences. The game should be easier if the player pokemon has a higher level than the opponent for example.
- Focus on getting the core mechanics right, and then being able to scope the game. Choose how many types, moves and pokemon the base game should have. 
  Leave room for future additions, but the MVP should be achieved.
- Try and find out how testing can be incorporated. Part of the exploration is that the Rule System can be regression tested with Vitest.
  - **Testing Approach**: Using spies on the enemy game object to verify movement behavior, and checking fact assertions and state changes. See `packages/skirmish/tests/EnemyAITests.spec.res` for examples. Run tests with `bun run test`.

## Enemy AI Rule System Implementation

The enemy AI uses a rule-based system built on top of Kaplay's `RuleSystem` component. The implementation is located in `packages/skirmish/src/EnemyAI.res` and follows a fact decomposition pattern.

### Architecture Overview

The rule system is **reset on every update** (see `update` function). This means:
- All facts are cleared before each execution cycle
- Facts are computed fresh each frame based on current game state
- **Do NOT use `assertFact`/`retractFact` pairs** for state management
- Instead, use `addRuleAssertingFact` or `addRuleExecutingAction` with `assertFact` to compute facts from game state

### Salience Tiers

Rules are organized into three salience tiers to ensure proper execution order:

1. **Base Facts** (salience 0.0): Facts computed directly from game state
   - Attack positions (`attackInCenterOfEnemy`, `attackOnTheLeftOfEnemy`, `attackOnTheRightOfEnemy`)
   - Space availability (`hasSpaceOnTheLeft`, `hasSpaceOnTheRight`)
   - Player position (`isPlayerLeft`, `isPlayerRight`)

2. **Derived Facts** (salience 10.0): Facts computed from other facts
   - Threat levels (`leftThreat`, `rightThreat`) - combines attack positions
   - Preferred dodge direction (`preferredDodgeLeft`, `preferredDodgeRight`) - computed from threats and space

3. **Decisions** (salience 20.0): Action rules that set movement direction
   - Dodging behavior when under center attack
   - Positioning behavior when no attacks are present

### Fact Decomposition Pattern

The implementation follows a fact decomposition pattern where complex logic is broken down into smaller, focused facts:

- **Positional Facts**: Describe where things are (`attackOnTheLeftOfEnemy`, `isPlayerRight`)
- **Space Facts**: Describe available space (graded 0.0-1.0 for continuous values)
- **Threat Facts**: Combine multiple attack facts into threat levels
- **Direction Facts**: Preferred movement direction based on threats and space

This makes rules declarative ("when X fact is true, do Y") rather than imperative ("calculate X, then if X > Y, compute Z...").

### Key Implementation Details

1. **Attack Detection**: Uses `overlapX` to detect if attacks overlap with enemy's horizontal bounds. Grades are computed based on squared distance from enemy's personal space.

2. **Oscillation Prevention**: 
   - For equal threats: Keeps current direction to avoid oscillation
   - For positioning: Uses 1-pixel threshold to prevent jitter when aligned

3. **State Management**: Movement direction is stored in `ruleSystemState.horizontalMovement` (persists between frames, unlike facts which reset)

4. **Priority System**: Dodging (when center attack exists) takes priority over positioning (when no attacks). Both run at salience 20.0, but dodging rule is checked first.

### Testing

Tests are located in `packages/skirmish/tests/EnemyAITests.spec.res` and can be run with `bun run test`. The test suite includes:

- Attack detection tests (center, left, right attacks)
- Positioning tests (moving toward player when no attacks)
- Movement verification using spies on the enemy's `move` method
- Fact assertion verification

The `withKaplayContext` helper creates a test environment with a playing field represented as a 2D array of characters (`P` = player, `E` = enemy, `A` = attack, `.` = empty).

## TBD / Future Considerations

The following systems are still being designed and may be implemented later:

- **Power Points (PP) System**: How PP limits work, whether PP depletes per use, and if/how PP replenishes.
- **Type Effectiveness**: Implementation of type-based damage multipliers (0.5x, 1x, 2x) based on move type vs pokemon type.
- **Level/Stats Scaling**: How pokemon levels affect HP, damage, move availability, movement speed, and other stats.
- **MVP Scope**: 
  - Number of pokemon types (TBD)
  - Number of move types (TBD)
  - Number of pokemon in base game (TBD - depends on how easily new moves can be added)
  - Number of moves per pokemon (minimum 2, max 4)