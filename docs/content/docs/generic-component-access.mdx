---
title: Generic Component Access
description: Learn how to access component methods on generic game objects from queries.
slug: generic-component-access
---

import { Aside } from "@astrojs/starlight/components";

When using [Context.query()](../api-reference/Kaplay.Context#query) or other generic game object queries, you often need to call component methods on objects where you don't know the specific type. The `Unit` module pattern provides a type-safe way to access component methods on generic objects.

## The Problem

When you query for game objects by tag, you get back generic objects:

```ReScript
let objects = k->Context.query({
  include_: ["movable"],
  hierarchy: Descendants,
})
// objects: array<'gameObj> - but what type?
```

You need to call component methods like `worldPos()` or `getPos()` on these objects, but you don't know their specific type. You could use `GameObjRaw.Unit.has()` to check for components, but you still need a way to call the component methods.

## The Solution: Unit Modules

A `Unit` module provides a generic type (`unit`) that includes the component's `Comp` module, giving you access to all component methods on generic objects.

### Example: Pos.Unit

```ReScript
module Pos = {
  // ... component definition ...
  
  module Unit = {
    type t = unit
    include Comp({type t = unit})
  }
}
```

Now you can use it with query results:

```ReScript
let getMovableObjects = (k: Context.t): array<Pos.Unit.t> => {
  // Note that using a `Pos.Comp` does not automatically add the `movable` tag to the object.
  k
  ->Context.query({
    include_: ["movable"],
    hierarchy: Descendants,
  })->Array.filterMap(obj => {
    if obj->GameObjRaw.Unit.has("pos") {
      Some(obj)
    } else {
      None
    }
  })
}

// Now you can call Pos methods on generic objects:
let getObjectPosition = (obj: Pos.Unit.t) => {
  let worldPos = obj->Pos.Unit.worldPos
  // ... use worldPos ...
}
```

<Aside type="note">
Not every component in the library has a `Unit` module. This was a recent addition to the library and thus not all components have one yet.
If you find yourself needing a `Unit` module for a component that doesn't have one, pull requests are welcome!
</Aside>

## When to Create Unit Modules

Create `Unit` modules only when:

1. **You commonly query for objects by tag** (not by specific type)
2. **You need to call component methods** on those generic query results
3. **The component provides domain-specific functionality** that's useful in generic contexts

### Good Candidates

- `GameObjRaw.Unit` - Generic operations like `has()`, `destroy()`, `onUpdate()`
- `Pos.Unit` - When you need to access position methods (`worldPos()`, `getPos()`, etc.) on generic objects
- Custom components with query-specific methods

### Not Needed

Most components (Sprite, Health, Color, etc.) are typically used on typed objects where you know the concrete type. Adding `Unit` modules for everything would:
- Add unnecessary maintenance overhead
- Clutter the API
- Be rarely used

## Combining Multiple Components

If you commonly need multiple components together on generic objects, create a custom combined module:

```ReScript
module Collidable = {
  module Unit = {
    type t = unit
    include GameObjRaw.Comp({type t = t})
    include Pos.Comp({type t = t})
    include Area.Comp({type t = t})
  }
}

// Usage:
let getCollidables = (k: Context.t): array<Collidable.Unit.t> => {
  k->Context.query({
    include_: ["collidable"],
  })
}

// Now you can use both Pos and Area methods:
let checkCollision = (obj: Collidable.Unit.t, point: Vec2.World.t) => {
  let worldPos = obj->Collidable.Unit.worldPos
  obj->Collidable.Unit.hasPoint(point)
}
```

This approach:
- **Domain-specific**: Tailored to your use case
- **Composable**: Uses the same `include` pattern as regular game objects
- **Type-safe**: You get all methods from all included components
- **Flexible**: Easy to add more components later

## Best Practices

1. **Keep it focused**: Only create `Unit` modules for components you actually use in generic contexts
2. **Domain-specific**: Create combined `Unit` modules in your game code, not in the library
3. **Type safety**: Always check for component presence with `has()` before using methods if the query might return objects without the component

This pattern enables powerful abstractions for spatial queries, rule systems, and other scenarios where you need to work with objects generically.

