---
title: Generic Component Access
description: Learn how to access component methods on generic game objects from queries.
slug: generic-component-access
---

When using `Context.query()` or other generic game object queries, you often need to call component methods on objects where you don't know the specific type. The `Unit` module pattern provides a type-safe way to access component methods on generic objects.

## The Problem

When you query for game objects by tag, you get back generic objects:

```ReScript
let attacks = k->Context.query({
  include_: [Attack.tag, Team.player],
  hierarchy: Descendants,
})
// attacks: array<'gameObj> - but what type?
```

You need to call component methods like `getWorldRect()` on these objects, but you don't know their specific type. You could use `GameObjRaw.Unit.has()` to check for components, but you still need a way to call the component methods.

## The Solution: Unit Modules

A `Unit` module provides a generic type (`unit`) that includes the component's `Comp` module, giving you access to all component methods on generic objects.

### Example: Attack.Unit

```ReScript
module Attack = {
  // ... component definition ...
  
  module Unit = {
    type t = unit
    include Comp({type t = unit})
  }
}
```

Now you can use it with query results:

```ReScript
let getPlayerAttacks = (k: Context.t): array<Attack.Unit.t> => {
  k
  ->Context.query({
    include_: [Attack.tag, Team.player],
    hierarchy: Descendants,
  })->Array.filterMap(attack => {
    if attack->GameObjRaw.Unit.has(Attack.tag) {
      Some(attack)
    } else {
      None
    }
  })
}

// Now you can call Attack methods on generic objects:
let checkAttack = (attack: Attack.Unit.t) => {
  let rect = attack->Attack.Unit.getWorldRect
  // ... use rect ...
}
```

## When to Create Unit Modules

Create `Unit` modules only when:

1. **You commonly query for objects by tag** (not by specific type)
2. **You need to call component methods** on those generic query results
3. **The component provides domain-specific functionality** that's useful in generic contexts

### Good Candidates

- `GameObjRaw.Unit` - Generic operations like `has()`, `destroy()`, `onUpdate()`
- `Attack.Unit` - Domain-specific queries where you need `getWorldRect()` on unknown attack types
- Custom components with query-specific methods

### Not Needed

Most components (Sprite, Health, Color, etc.) are typically used on typed objects where you know the concrete type. Adding `Unit` modules for everything would:
- Add unnecessary maintenance overhead
- Clutter the API
- Be rarely used

## Combining Multiple Components

If you commonly need multiple components together on generic objects, create a custom combined module:

```ReScript
module Collidable = {
  module Unit = {
    type t = unit
    include GameObjRaw.Comp({type t = t})
    include Pos.Comp({type t = t})
    include Area.Comp({type t = t})
  }
}

// Usage:
let getCollidables = (k: Context.t): array<Collidable.Unit.t> => {
  k->Context.query({
    include_: ["collidable"],
  })
}

// Now you can use both Pos and Area methods:
let checkCollision = (obj: Collidable.Unit.t, point: Vec2.World.t) => {
  let worldPos = obj->Collidable.Unit.worldPos
  obj->Collidable.Unit.hasPoint(point)
}
```

This approach:
- **Domain-specific**: Tailored to your use case
- **Composable**: Uses the same `include` pattern as regular game objects
- **Type-safe**: You get all methods from all included components
- **Flexible**: Easy to add more components later

## Best Practices

1. **Keep it focused**: Only create `Unit` modules for components you actually use in generic contexts
2. **Domain-specific**: Create combined `Unit` modules in your game code, not in the library
3. **Type safety**: Always check for component presence with `has()` before using methods if the query might return objects without the component

## Example: Real-World Usage

Here's how `Attack.Unit` is used in a rule system:

```ReScript
let getPlayerAttacks = (k: Context.t): array<Attack.Unit.t> => {
  k
  ->Context.query({
    include_: [Attack.tag, Team.player],
    hierarchy: Descendants,
  })->Array.filterMap(attack => {
    if attack->GameObjRaw.Unit.has(Attack.tag) {
      Some(attack)
    } else {
      None
    }
  })
}

// Later in a rule system:
rs.state.playerAttacks->Array.forEach(attack => {
  let attackRect = attack->Attack.Unit.getWorldRect
  let closestCorner = attack->Attack.Unit.getClosestCorner(
    k,
    ~pokemonPosition=enemy->Pokemon.worldPos,
  )
  // ... use attack data for AI decision-making ...
})
```

This pattern enables powerful abstractions for rule systems, spatial queries, and other scenarios where you need to work with objects generically.

