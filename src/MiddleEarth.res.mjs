// Generated by ReScript, PLEASE EDIT WITH CARE

import * as KaplayContext from "./KaplayContext.res.mjs";

let gameWidth = KaplayContext.k.width();

let gameHeight = KaplayContext.k.height();

let cameraBounds = {
  x: {
    min: gameWidth / 2,
    max: 1000 - gameWidth / 2
  },
  y: {
    min: gameHeight / 2,
    max: 563 - gameHeight / 2
  }
};

let zeroVector = KaplayContext.k.vec2(0, 0);

let cameraVelocity = {
  contents: zeroVector
};

let lastTouchStart = {
  contents: zeroVector
};

let isDragging = {
  contents: false
};

function updateCamera(result) {
  let currentCamPos = KaplayContext.k.getCamPos();
  let result$1 = currentCamPos.add(result);
  result$1.x = KaplayContext.k.clampFloat(result$1.x, cameraBounds.x.min, cameraBounds.x.max);
  result$1.y = KaplayContext.k.clampFloat(result$1.y, cameraBounds.y.min, cameraBounds.y.max);
  KaplayContext.k.tween(currentCamPos, result$1, 0.100, v => {
    KaplayContext.k.setCamPos(v);
  }, KaplayContext.k.easings.linear);
}

function scene() {
  KaplayContext.k.loadSprite("bg", "middle-earth.webp");
  let map = KaplayContext.k.add([
    KaplayContext.k.pos(0, 0),
    KaplayContext.k.sprite("bg", {
      width: 1000,
      height: 563
    }),
    KaplayContext.k.area()
  ]);
  KaplayContext.k.onTouchStart((pos, _touch) => {
    lastTouchStart.contents = pos;
    isDragging.contents = true;
    cameraVelocity.contents = zeroVector;
  });
  KaplayContext.k.onTouchMove((pos, _touch) => {
    if (!isDragging.contents) {
      return;
    }
    let delta = pos.sub(lastTouchStart.contents);
    cameraVelocity.contents = delta.scale(KaplayContext.k.vec2(-150, -100));
    lastTouchStart.contents = pos;
  });
  KaplayContext.k.onTouchEnd((param, _touch) => {
    isDragging.contents = false;
  });
  KaplayContext.k.onUpdate(() => {
    if (isDragging.contents) {
      return;
    }
    let currentVelocity = cameraVelocity.contents;
    if (currentVelocity.len() > 0.1) {
      updateCamera(currentVelocity);
      cameraVelocity.contents = currentVelocity.scale(KaplayContext.k.vec2(0.9, 0.9));
      return;
    }
    
  });
  map.onKeyDown(key => {
    let currentCamPos = KaplayContext.k.getCamPos();
    let move;
    switch (key) {
      case "left" :
        move = KaplayContext.k.vec2(- 10, 0);
        break;
      case "right" :
        move = KaplayContext.k.vec2(10, 0);
        break;
      case "up" :
        move = KaplayContext.k.vec2(0, - 10);
        break;
      case "down" :
        move = KaplayContext.k.vec2(0, 10);
        break;
      case "space" :
      case "enter" :
        move = KaplayContext.k.vec2(0, 0);
        break;
    }
    let result = currentCamPos.add(move);
    result.x = KaplayContext.k.clampFloat(result.x, cameraBounds.x.min, cameraBounds.x.max);
    result.y = KaplayContext.k.clampFloat(result.y, cameraBounds.y.min, cameraBounds.y.max);
    KaplayContext.k.setCamPos(result);
  });
}

let speed = 10;

let mapWidth = 1000;

let mapHeight = 563;

export {
  speed,
  mapWidth,
  mapHeight,
  gameWidth,
  gameHeight,
  cameraBounds,
  zeroVector,
  cameraVelocity,
  lastTouchStart,
  isDragging,
  updateCamera,
  scene,
}
/* gameWidth Not a pure module */
