// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Stdlib_Array from "rescript/lib/es6/Stdlib_Array.js";
import * as KaplayContext from "./KaplayContext.res.mjs";
import * as Stdlib_Option from "rescript/lib/es6/Stdlib_Option.js";

let tileSizeVec2 = KaplayContext.k.vec2(16, 16);

function make(maxSize) {
  return {
    items: [],
    maxSize: maxSize
  };
}

function enqueue(t, item) {
  t.items.push(item);
  if (t.items.length > t.maxSize) {
    t.items.shift();
    return;
  }
  
}

function dequeue(t) {
  return t.items.shift();
}

function peek(t) {
  return t.items[0];
}

let Queue = {
  make: make,
  enqueue: enqueue,
  dequeue: dequeue,
  peek: peek
};

function addSegment(self, pos, extraComponentsOpt) {
  let extraComponents = extraComponentsOpt !== undefined ? extraComponentsOpt : [];
  if (!self.has("snake")) {
    throw {
      RE_EXN_ID: "Invalid_argument",
      _1: "Your gameObj does not have the snake component",
      Error: new Error()
    };
  }
  let segment = self.add(Belt_Array.concatMany([
    [
      KaplayContext.k.pos(pos),
      KaplayContext.k.rect(16, 16),
      KaplayContext.k.color(KaplayContext.k.Color.fromHex("#00d492")),
      KaplayContext.k.outline(1, KaplayContext.k.Color.fromHex("#000000")),
      KaplayContext.k.area(),
      "segment"
    ],
    extraComponents
  ]));
  self.segments.push(segment);
}

function tryLastSegmentPos(gameObj) {
  if (!gameObj.has("snake")) {
    throw {
      RE_EXN_ID: "Invalid_argument",
      _1: "Your gameObj does not have the snake component",
      Error: new Error()
    };
  }
  return Stdlib_Option.map(Stdlib_Array.last(gameObj.segments), segment => segment.pos);
}

function make$1() {
  return {
    id: "snake",
    update: function () {
      let snake = this ;
      snake.timeSinceLastMove = snake.timeSinceLastMove + KaplayContext.k.dt();
      if (snake.timeSinceLastMove <= 0.22) {
        return;
      }
      let previousPositions = snake.segments.map(segment => segment.pos);
      let segment = snake.segments[0];
      if (segment !== undefined) {
        let nextDirection = snake.inputQueue.items.shift();
        if (nextDirection !== undefined && nextDirection.dot(snake.direction) >= 0) {
          snake.direction = nextDirection;
        }
        segment.pos = segment.pos.add(snake.direction.scale(tileSizeVec2));
      }
      for (let i = 1, i_finish = snake.segments.length; i < i_finish; ++i) {
        let match = snake.segments[i];
        let match$1 = previousPositions[i - 1 | 0];
        if (match !== undefined && match$1 !== undefined) {
          match.pos = match$1;
        }
        
      }
      snake.timeSinceLastMove = 0;
    },
    add: function () {
      let snake = this ;
      snake.segments = [];
      snake.direction = KaplayContext.k.Vec2.RIGHT;
      snake.timeSinceLastMove = 0;
      snake.inputQueue = {
        items: [],
        maxSize: 2
      };
      snake.onKeyPress(key => {
        let intendedDirection;
        switch (key) {
          case "left" :
            intendedDirection = KaplayContext.k.Vec2.LEFT;
            break;
          case "right" :
            intendedDirection = KaplayContext.k.Vec2.RIGHT;
            break;
          case "up" :
            intendedDirection = KaplayContext.k.Vec2.UP;
            break;
          case "down" :
            intendedDirection = KaplayContext.k.Vec2.DOWN;
            break;
          case "space" :
          case "enter" :
            intendedDirection = undefined;
            break;
        }
        if (intendedDirection === undefined) {
          return;
        }
        let lastDirection = snake.inputQueue.items[0];
        let currentEffectiveDirection = lastDirection !== undefined ? lastDirection : snake.direction;
        let isReversal = intendedDirection.dot(currentEffectiveDirection) < 0;
        if (!isReversal) {
          return enqueue(snake.inputQueue, intendedDirection);
        }
        
      });
      for (let i = 0; i <= 2; ++i) {
        let pos = KaplayContext.k.vec2(i * - 16, 0);
        if (i === 0) {
          addSegment(snake, pos, ["head"]);
        } else {
          addSegment(snake, pos, undefined);
        }
      }
    }
  };
}

let Snake = {
  addSegment: addSegment,
  tryLastSegmentPos: tryLastSegmentPos,
  make: make$1
};

function addCoin(snake, grid) {
  while (true) {
    let randomPosition = KaplayContext.k.vec2(KaplayContext.k.randi(1, 19), KaplayContext.k.randi(1, 19));
    if (snake.get("segment").every(segment => !segment.hasPoint(randomPosition))) {
      let coin = grid.spawn([
        KaplayContext.k.area({
          offset: KaplayContext.k.vec2(16 / 4, 16 / 4),
          scale: 0.5
        }),
        "coin",
        KaplayContext.k.rect(16, 16),
        KaplayContext.k.color(KaplayContext.k.Color.fromHex("#ffd700")),
        KaplayContext.k.outline(1, KaplayContext.k.Color.fromHex("#000000")),
        KaplayContext.k.z(-1)
      ], randomPosition);
      coin.onCollideEnd("head", _segment => {
        coin.destroy();
        let lastSegmentPos = tryLastSegmentPos(snake);
        if (lastSegmentPos !== undefined) {
          addSegment(snake, lastSegmentPos, undefined);
        }
        addCoin(snake, grid);
      });
      return;
    }
    continue;
  };
}

function scene() {
  let grid = KaplayContext.k.addLevel(Belt_Array.concatMany([
    ["x".repeat(20)],
    Stdlib_Array.fromInitializer(18, param => "x" + " ".repeat(18) + "x"),
    ["x".repeat(20)]
  ]), {
    tileWidth: 16,
    tileHeight: 16,
    tiles: {
      x: () => [
        KaplayContext.k.area(),
        KaplayContext.k.rect(16, 16),
        KaplayContext.k.color(KaplayContext.k.Color.fromHex("#a684ff")),
        "wall",
        KaplayContext.k.outline(1, KaplayContext.k.Color.fromHex("#000000"))
      ]
    }
  });
  let snake = grid.spawn([make$1()], KaplayContext.k.vec2(KaplayContext.k.randi(10, 10), KaplayContext.k.randi(10, 10)));
  addCoin(snake, grid);
}

let gridSize = 20;

let tileSize = 16;

let moveInterval = 0.22;

export {
  gridSize,
  tileSize,
  tileSizeVec2,
  moveInterval,
  Queue,
  Snake,
  addCoin,
  scene,
}
/* tileSizeVec2 Not a pure module */
