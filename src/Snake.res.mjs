// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Stdlib_Array from "rescript/lib/es6/Stdlib_Array.js";
import * as KaplayContext from "./KaplayContext.res.mjs";
import * as Stdlib_Option from "rescript/lib/es6/Stdlib_Option.js";

let tileSizeVec2 = KaplayContext.k.vec2(16, 16);

let score = {
  contents: 0
};

function make(maxSize) {
  return {
    items: [],
    maxSize: maxSize
  };
}

function enqueue(t, item) {
  t.items.push(item);
  if (t.items.length > t.maxSize) {
    t.items.shift();
    return;
  }
  
}

function dequeue(t) {
  return t.items.shift();
}

function peek(t) {
  return t.items[0];
}

let Queue = {
  make: make,
  enqueue: enqueue,
  dequeue: dequeue,
  peek: peek
};

function addSegment(self, pos, isHeadOpt) {
  let isHead = isHeadOpt !== undefined ? isHeadOpt : false;
  if (!self.has("snake")) {
    throw {
      RE_EXN_ID: "Invalid_argument",
      _1: "Your gameObj does not have the snake component",
      Error: new Error()
    };
  }
  let state = self.snake;
  let segment = self.add(Belt_Array.concatMany([
    [
      KaplayContext.k.pos(pos),
      KaplayContext.k.rect(16, 16),
      KaplayContext.k.color(KaplayContext.k.Color.fromHex("#00d492")),
      KaplayContext.k.outline(1, KaplayContext.k.Color.fromHex("#000000")),
      KaplayContext.k.area(),
      "segment"
    ],
    isHead ? ["head"] : []
  ]));
  state.segments.push(segment);
}

function tryLastSegmentPos(gameObj) {
  if (!gameObj.has("snake")) {
    throw {
      RE_EXN_ID: "Invalid_argument",
      _1: "Your gameObj does not have the snake component",
      Error: new Error()
    };
  }
  return Stdlib_Option.map(Stdlib_Array.last(gameObj.snake.segments), segment => segment.pos);
}

function make$1() {
  return {
    id: "snake",
    update: function () {
      let snake = this ;
      let state = snake.snake;
      if (state.isDead) {
        return;
      }
      state.timeSinceLastMove = state.timeSinceLastMove + KaplayContext.k.dt();
      if (state.timeSinceLastMove <= 0.50) {
        return;
      }
      let headSegment = state.segments[0];
      if (headSegment === undefined) {
        return;
      }
      let nextDirection = state.inputQueue.items.shift();
      if (nextDirection !== undefined && nextDirection.dot(state.direction) >= 0) {
        state.direction = nextDirection;
      }
      let nextPos = headSegment.worldPos().add(state.direction.scale(tileSizeVec2));
      let walls = KaplayContext.k.get("wall", {
        recursive: true
      });
      let willCollide = walls.some(wall => wall.hasPoint(nextPos));
      if (willCollide) {
        state.isDead = true;
        return;
      }
      let previousPositions = state.segments.map(segment => segment.pos);
      headSegment.worldPos(nextPos);
      for (let i = 1, i_finish = state.segments.length; i < i_finish; ++i) {
        let match = state.segments[i];
        let match$1 = previousPositions[i - 1 | 0];
        if (match !== undefined && match$1 !== undefined) {
          match.pos = match$1;
        }
        
      }
      state.timeSinceLastMove = 0;
    },
    add: function () {
      let snake = this ;
      snake.snake = {
        segments: [],
        direction: KaplayContext.k.Vec2.RIGHT,
        timeSinceLastMove: 0,
        inputQueue: {
          items: [],
          maxSize: 2
        },
        isDead: false
      };
      snake.onKeyPress(key => {
        let intendedDirection;
        switch (key) {
          case "left" :
            intendedDirection = KaplayContext.k.Vec2.LEFT;
            break;
          case "right" :
            intendedDirection = KaplayContext.k.Vec2.RIGHT;
            break;
          case "up" :
            intendedDirection = KaplayContext.k.Vec2.UP;
            break;
          case "down" :
            intendedDirection = KaplayContext.k.Vec2.DOWN;
            break;
          case "space" :
          case "enter" :
            intendedDirection = undefined;
            break;
        }
        if (intendedDirection === undefined) {
          return;
        }
        let state = snake.snake;
        let lastDirection = state.inputQueue.items[0];
        let currentEffectiveDirection = lastDirection !== undefined ? lastDirection : state.direction;
        let isReversal = intendedDirection.dot(currentEffectiveDirection) < 0;
        if (!isReversal) {
          return enqueue(state.inputQueue, intendedDirection);
        }
        
      });
      for (let i = 0; i <= 2; ++i) {
        let pos = KaplayContext.k.vec2(i * - 16, 0);
        addSegment(snake, pos, i === 0);
      }
    }
  };
}

let Snake = {
  addSegment: addSegment,
  tryLastSegmentPos: tryLastSegmentPos,
  make: make$1
};

function addCoin(snake, grid, scoreText) {
  while (true) {
    let randomPosition = KaplayContext.k.vec2(KaplayContext.k.randi(1, 9), KaplayContext.k.randi(1, 9));
    if (snake.get("segment").every(segment => !segment.hasPoint(randomPosition))) {
      let coin = grid.spawn([
        KaplayContext.k.area({
          offset: KaplayContext.k.vec2(16 / 4, 16 / 4),
          scale: 0.5
        }),
        "coin",
        KaplayContext.k.rect(16, 16),
        KaplayContext.k.color(KaplayContext.k.Color.fromHex("#ffd700")),
        KaplayContext.k.outline(1, KaplayContext.k.Color.fromHex("#000000")),
        KaplayContext.k.z(-1)
      ], randomPosition);
      coin.onCollideEnd("head", _segment => {
        coin.destroy();
        let lastSegmentPos = tryLastSegmentPos(snake);
        if (lastSegmentPos !== undefined) {
          addSegment(snake, lastSegmentPos, undefined);
        }
        score.contents = score.contents + 1 | 0;
        scoreText.text = "Score: " + score.contents.toString();
        addCoin(snake, grid, scoreText);
      });
      return;
    }
    continue;
  };
}

function scene() {
  let grid = KaplayContext.k.addLevel(Belt_Array.concatMany([
    ["x".repeat(10)],
    Stdlib_Array.fromInitializer(8, param => "x" + " ".repeat(8) + "x"),
    ["x".repeat(10)]
  ]), {
    tileWidth: 16,
    tileHeight: 16,
    tiles: {
      x: () => [
        KaplayContext.k.area(),
        KaplayContext.k.rect(16, 16),
        KaplayContext.k.color(KaplayContext.k.Color.fromHex("#a684ff")),
        "wall",
        KaplayContext.k.outline(1, KaplayContext.k.Color.fromHex("#000000")),
        KaplayContext.k.z(1)
      ]
    }
  });
  let snake = grid.spawn([make$1()], KaplayContext.k.vec2(KaplayContext.k.randi(1, 8), KaplayContext.k.randi(1, 8)));
  let scoreText = KaplayContext.k.add([
    KaplayContext.k.text("Score: 0"),
    KaplayContext.k.pos(KaplayContext.k.vec2(30, 200))
  ]);
  addCoin(snake, grid, scoreText);
}

let gridSize = 10;

let tileSize = 16;

let moveInterval = 0.50;

export {
  gridSize,
  tileSize,
  tileSizeVec2,
  moveInterval,
  score,
  Queue,
  Snake,
  addCoin,
  scene,
}
/* tileSizeVec2 Not a pure module */
